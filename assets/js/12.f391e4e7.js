(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{439:function(t,a,s){"use strict";s.r(a);var e=s(0),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/vtIHUlR92GQVG6UW74PEqQ",target:"_blank",rel:"noopener noreferrer"}},[t._v("InnoDB记录存储结构"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/weixin_41862308/article/details/106796791",target:"_blank",rel:"noopener noreferrer"}},[t._v("一文搞懂InnoDB索引存储结构"),a("OutboundLink")],1)]),t._v(" "),a("h1",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("对于InnoDB存储引擎来说，在单个页中查找某条记录分为两种情况：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("以主键为搜索条件，可以使用Page Directory通过二分法快速定位相应的用户记录。")])]),t._v(" "),a("li",[a("p",[t._v("以其他列为搜索条件，需要按照记录组成的单链表依次遍历各条记录。")])]),t._v(" "),a("li",[a("p",[t._v("没有索引的情况下，不论是以主键还是其他列作为搜索条件，只能沿着页的双链表从左到右依次遍历各个页。")])]),t._v(" "),a("li",[a("p",[t._v("InnoDB存储引擎的索引是一棵B+树，完整的用户记录都存储在B+树第0层的叶子节点，其他层次的节点都属于内节点，内节点里存储的是目录项记录。InnoDB的索引分为两大种：")])])]),t._v(" "),a("h2",{attrs:{id:"聚簇索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聚簇索引"}},[t._v("#")]),t._v(" 聚簇索引")]),t._v(" "),a("ul",[a("li",[t._v("以主键值的大小为页和记录的排序规则，在叶子节点处存储的记录包含了表中所有的列。")])]),t._v(" "),a("h2",{attrs:{id:"二级索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二级索引"}},[t._v("#")]),t._v(" 二级索引")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("以自定义的列的大小为页和记录的排序规则，在叶子节点处存储的记录内容是列 + 主键。")])]),t._v(" "),a("li",[a("p",[t._v("MyISAM存储引擎的数据和索引分开存储，这种存储引擎的索引全部都是二级索引，在叶子节点处存储的是列 + 页号。")])]),t._v(" "),a("li",[a("p",[t._v("每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。")])]),t._v(" "),a("li",[a("p",[t._v("InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。")])]),t._v(" "),a("li",[a("p",[t._v("我们可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。")])]),t._v(" "),a("li",[a("p",[t._v("B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录按照先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。")])]),t._v(" "),a("li",[a("p",[t._v("通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快")])])]),t._v(" "),a("h2",{attrs:{id:"回表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回表"}},[t._v("#")]),t._v(" 回表")]),t._v(" "),a("p",[t._v("通过二级索引只能确定我们要查找记录的主键值，所以如果我们想通过二级所应查找到完整的记录的话，仍需要到聚簇索引中再查一遍，这个过程也被称为"),a("strong",[t._v("回表")]),t._v("，也就是根据"),a("strong",[t._v("非主键列")]),t._v("的值查询一条完整的用户记录需要使用到2棵B+树！！！")]),t._v(" "),a("h2",{attrs:{id:"索引的代价"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引的代价"}},[t._v("#")]),t._v(" 索引的代价")]),t._v(" "),a("blockquote",[a("p",[t._v("空间上的代价")])]),t._v(" "),a("ul",[a("li",[t._v("这个是显而易见的，每建立一个索引都为要它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那可是很大的一片存储空间呢。")])]),t._v(" "),a("blockquote",[a("p",[t._v("时间上的代价")])]),t._v(" "),a("ul",[a("li",[t._v("每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，这还能不给性能拖后腿么？")])]),t._v(" "),a("p",[t._v("所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们先得学学这些索引在哪些条件下起作用的。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/wangen2010/article/details/100184462",target:"_blank",rel:"noopener noreferrer"}},[t._v("好东西也得先学会怎么用 —— B+ 树索引的使用"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"最左匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最左匹配"}},[t._v("#")]),t._v(" 最左匹配")]),t._v(" "),a("blockquote",[a("p",[t._v("为什么联合索引需要最左匹配")])]),t._v(" "),a("ul",[a("li",[t._v("因为建立索引是从左边的值开始的排序的，在第一个值相同的情况下才用第二个值去排序的，也就是说第一个列的值不同的记录中第二列的值可能是无序的。而现在你跳过第一列直接根据第二列的值去查找，这样无序查找当然找不到索引失效。")])]),t._v(" "),a("h2",{attrs:{id:"覆盖索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引"}},[t._v("#")]),t._v(" 覆盖索引")]),t._v(" "),a("p",[a("strong",[t._v("查询列表里只包含索引列")]),t._v("，比如这样：")]),t._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" birthday"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" phone_number "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" person_info "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Asa'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Barlow'")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("因为我们只查询"),a("code",[t._v("name, birthday, phone_number")]),t._v("这三个索引列的值，所以在通过"),a("code",[t._v("idx_name_birthday_phone_number")]),t._v("索引得到结果后就不必到聚簇索引中再查找记录的剩余列，也就是"),a("code",[t._v("country")]),t._v("列的值了，这样就省去了回表操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为"),a("strong",[t._v("索引覆盖")]),t._v("。")]),t._v(" "),a("p",[t._v("排序操作也优先使用覆盖索引的方式进行查询，比方说这个查询：")]),t._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" birthday"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" phone_number  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" person_info "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" birthday"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" phone_number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("虽然这个查询中没有"),a("code",[t._v("LIMIT")]),t._v("子句，但是采用了覆盖索引，所以查询优化器就会直接使用"),a("code",[t._v("idx_name_birthday_phone_number")]),t._v("索引进行排序而不需要回表操作了。")]),t._v(" "),a("p",[t._v("当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是我们很不鼓励用*号作为查询列表，最好把我们需要查询的列依次标明。")])])}),[],!1,null,null,null);a.default=r.exports}}]);