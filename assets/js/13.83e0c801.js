(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{437:function(_,v,t){"use strict";t.r(v);var s=t(0),a=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[_._v("#")]),_._v(" 事务")]),_._v(" "),v("p",[_._v("事务（\t"),v("code",[_._v("Transaction")]),_._v("，简写为 "),v("code",[_._v("tx")]),_._v("）,由一步或几步数据库操作（"),v("code",[_._v("DML")]),_._v(" 语句）序列组成的逻辑执行单元，这系列操作要么全部执行，要么全部放弃执行（一组原子性的 "),v("code",[_._v("SQL")]),_._v(" 査询）")]),_._v(" "),v("h1",{attrs:{id:"事务的-4-个特性-acid-性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的-4-个特性-acid-性"}},[_._v("#")]),_._v(" 事务的 4 个特性（ACID 性）")]),_._v(" "),v("p",[v("strong",[_._v("原子性（Atomicity）：")])]),_._v(" "),v("ul",[v("li",[_._v("事务是数据库的逻辑工作单位，事务中包含的所有操作要么全部提交成功，要么全部失败回滚")])]),_._v(" "),v("p",[v("strong",[_._v("一致性（Consistency）：")])]),_._v(" "),v("ul",[v("li",[_._v("事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态")])]),_._v(" "),v("p",[v("strong",[_._v("隔离性（Isolation）：")])]),_._v(" "),v("ul",[v("li",[_._v("一个事务所做的修改在最终提交以前，对其它事务是不可见的")])]),_._v(" "),v("p",[v("strong",[_._v("持久性（Durability）：")])]),_._v(" "),v("ul",[v("li",[_._v("也称永久性，一个事务一旦提交，则其所做的修改就会永久保存到数据库中，接下来的其它操作或故障不会对其执行结果有任何影响")])]),_._v(" "),v("p",[v("code",[_._v("Mysql")]),_._v(" 事务的 "),v("code",[_._v("ACID")]),_._v(" 是通过"),v("code",[_._v("InnoDB")]),_._v(" 日志和锁来保证：事务的隔离性是通过数据库锁的机制实现的，原子性和持久性通过 "),v("code",[_._v("redo log（重做日志）")]),_._v("来实现，一致性通过 "),v("code",[_._v("undo log")]),_._v(" 来实现。在修改表的数据时，先需要修改其内存拷贝，再把该修改行为记录到重做日志 "),v("code",[_._v("Buffer（redo log buffer）")]),_._v("中，在事务结束后将重做日志写入磁盘，并通知文件系统刷新缓存中的数据到磁盘文件。")]),_._v(" "),v("h1",{attrs:{id:"事务控制的命令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务控制的命令"}},[_._v("#")]),_._v(" 事务控制的命令")]),_._v(" "),v("p",[v("code",[_._v("begin")]),_._v(" 或 "),v("code",[_._v("start transaction")]),_._v("、"),v("code",[_._v("commit")]),_._v("、"),v("code",[_._v("rollback")])]),_._v(" "),v("h1",{attrs:{id:"事务自动提交"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务自动提交"}},[_._v("#")]),_._v(" 事务自动提交")]),_._v(" "),v("ul",[v("li",[_._v("MySQL 默认采用自动提交"),v("code",[_._v("（autocommit = 1）")]),_._v("模式，即如果不是显式地开始一个事务，则毎个查询都被当作一个事务执行提交操作")]),_._v(" "),v("li",[_._v("在执行 "),v("code",[_._v("DDL")]),_._v("、"),v("code",[_._v("DCL")]),_._v(" 操作之前会强制执行 "),v("code",[_._v("commit")]),_._v(" 提交当前的活动事务")])]),_._v(" "),v("h1",{attrs:{id:"事务并发问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务并发问题"}},[_._v("#")]),_._v(" 事务并发问题")]),_._v(" "),v("p",[v("strong",[_._v("脏读")])]),_._v(" "),v("ul",[v("li",[_._v("一个事务读到另一个事务未提交的更新数据")])]),_._v(" "),v("p",[v("strong",[_._v("不可重复读")])]),_._v(" "),v("ul",[v("li",[_._v("一个事务两次读同一行数据，期间有另一个事务提交了更新，导致这两次读到的数据不一样")])]),_._v(" "),v("p",[v("strong",[_._v("幻读")])]),_._v(" "),v("ul",[v("li",[_._v("一个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当再次读取该范围的记录时，会产生幻行")])]),_._v(" "),v("p",[v("strong",[_._v("第一类丢失更新（回滚丢失）")])]),_._v(" "),v("ul",[v("li",[_._v("撤消一个事务时，把其它事务已提交的更新的数据回滚掉了")])]),_._v(" "),v("p",[v("strong",[_._v("第二类丢失更新（覆盖丢失）")])]),_._v(" "),v("ul",[v("li",[_._v("提交一个事务时，把其它事务已提交的更新的数据覆盖了")])]),_._v(" "),v("h1",{attrs:{id:"事务隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[_._v("#")]),_._v(" 事务隔离级别")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("应用程序设计者可以允许并发的事务运行在不同的隔离级别上，从而牺牲一些正确性来换取更大的吞吐量。")])]),_._v(" "),v("li",[v("p",[_._v("低的隔离级别提高了事务的并发程度，但是增加了数据库中含有不正确数据的风险。")])]),_._v(" "),v("li",[v("p",[_._v("有一些事务运行在最高的隔离级别，但是有另外一些事务却运行在较低的，可以访问未提交状态的隔离级别。")])]),_._v(" "),v("li",[v("p",[_._v("运行在较低隔离级别的事务可能产生无效的数据。应用程序设计者必须阻止之后运行在较高隔离级别的事务去访问这些无效的数据，继而传播错误。")])])]),_._v(" "),v("p",[v("strong",[_._v("读未提交")])]),_._v(" "),v("ul",[v("li",[_._v("事务中的修改，即使没有提交，对其它事务也都是可见的")])]),_._v(" "),v("p",[v("strong",[_._v("读已提交")])]),_._v(" "),v("ul",[v("li",[_._v("一个事务开始时，只能“看见”其它已经提交的事务所做的修改")])]),_._v(" "),v("p",[v("strong",[_._v("可重复读")])]),_._v(" "),v("ul",[v("li",[_._v("同一个事务中多次读取同样记录的结果是一致的，当 A 事务修改了一条记录但未提交时，B 事务将不允许修改这条记录（会被阻塞，"),v("code",[_._v("innodb_lock_wait_timeout")]),_._v("，默认是 50s）")])]),_._v(" "),v("p",[v("strong",[_._v("可串行化")])]),_._v(" "),v("ul",[v("li",[_._v("事务顺序执行，事务在读取的毎一行数据上都加锁")])]),_._v(" "),v("blockquote",[v("p",[v("code",[_._v("InnoDB")]),_._v(" 默认的事务隔离级别是 "),v("code",[_._v("Repeatable Read（可重复读）")]),_._v("，并且通过"),v("code",[_._v("间隙锁（next-key locking）")]),_._v("策略防止幻读的出现")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/2020070919002576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),v("h1",{attrs:{id:"事务隔离级别实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别实现"}},[_._v("#")]),_._v(" 事务隔离级别实现")]),_._v(" "),v("p",[_._v("在实现上，数据库里面会创建一个"),v("strong",[_._v("视图")]),_._v("，访问的时候以视图的逻辑结果为准。在"),v("code",[_._v("可重复读")]),_._v("隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在"),v("code",[_._v("读提交")]),_._v("隔离级别下，这个视图是在每个 "),v("code",[_._v("SQL")]),_._v(" 语句开始执行的时候创建的。这里需要注意的是，"),v("code",[_._v("读未提交")]),_._v("隔离级别下直接返回记录上的最新值，没有视图概念；而"),v("code",[_._v("串行化")]),_._v("隔离级别下直接用加锁的方式来避免并行访问。")]),_._v(" "),v("p",[_._v("我们可以看到在不同的隔离级别下，数据库行为是有所不同的。"),v("code",[_._v("Oracle")]),_._v(" 数据库的默认隔离级别其实就是“读提交”，因此对于一些从 "),v("code",[_._v("Oracle")]),_._v(" 迁移到 "),v("code",[_._v("MySQL")]),_._v(" 的应用，为保证数据库隔离级别的一致，你一定要记得将 "),v("code",[_._v("MySQL")]),_._v(" 的隔离级别设置为“读提交”。")]),_._v(" "),v("p",[_._v("配置的方式是，将启动参数 "),v("code",[_._v("transaction-isolation")]),_._v(" 的值设置成 "),v("code",[_._v("READ-COMMITTED")]),_._v("。你可以用 "),v("code",[_._v("show variables")]),_._v(" 来查看当前的值。")]),_._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("show")]),_._v(" variables "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("like")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[_._v("'transaction_isolation'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[_._v("在 "),v("code",[_._v("MySQL")]),_._v(" 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。")]),_._v(" "),v("p",[v("strong",[_._v("记忆图")]),_._v(" "),v("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200709190440506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})])])}),[],!1,null,null,null);v.default=a.exports}}]);