(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{446:function(v,_,o){"use strict";o.r(_);var c=o(0),e=Object(c.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"mysql函数count"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql函数count"}},[v._v("#")]),v._v(" MySQL函数count")]),v._v(" "),_("h1",{attrs:{id:"count-的实现方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#count-的实现方式"}},[v._v("#")]),v._v(" count(*) 的实现方式")]),v._v(" "),_("p",[v._v("不同的 "),_("code",[v._v("MySQL")]),v._v("引擎中，"),_("code",[v._v("count(*)")]),v._v("有不同的实现方式。")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("MyISAM")]),v._v("引擎把一个表的总行数存在了磁盘上，因此执行 "),_("code",[v._v("count(*)")]),v._v("的时候会直接返回这个数，效率很高；")]),v._v(" "),_("li",[v._v("而 "),_("code",[v._v("InnoDB")]),v._v("引擎就麻烦了，它执行"),_("code",[v._v("count(*)")]),v._v("的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。")])]),v._v(" "),_("p",[_("strong",[v._v("为什么 "),_("code",[v._v("InnoDB")]),v._v(" 不跟 "),_("code",[v._v("MyISAM")]),v._v(" 一样，也把数字存起来呢？")])]),v._v(" "),_("p",[v._v("因为即使是在同一个时刻的多个查询，由于多版本并发控制（"),_("code",[v._v("MVCC")]),v._v("）的原因，"),_("code",[v._v("InnoDB")]),v._v("表“应该返回多少行”也是不确定的。")]),v._v(" "),_("p",[_("code",[v._v("InnoDB")]),v._v("事务默认的隔离级别是"),_("strong",[v._v("可重复读")]),v._v("，在代码上就是通过多版本并发控制，也就是 "),_("code",[v._v("MVCC")]),v._v("来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于"),_("code",[v._v("count(*)")]),v._v("请求来说，"),_("code",[v._v("InnoDB")]),v._v("只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。")]),v._v(" "),_("p",[_("strong",[v._v("InnoDB在执行 count(*) 操作的优化")])]),v._v(" "),_("p",[_("code",[v._v("InnoDB")]),v._v("是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 "),_("code",[v._v("count(*)")]),v._v(" 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，"),_("code",[v._v("MySQL")]),v._v("优化器会找到最小的那棵树来遍历。"),_("strong",[v._v("在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。")])]),v._v(" "),_("p",[v._v("如果你用过"),_("code",[v._v("show table status")]),v._v(" 命令的话，就会发现这个命令的输出结果里面也有一个 "),_("code",[v._v("TABLE_ROWS")]),v._v("用于显示这个表当前有多少行，这个命令执行挺快的，那这个 "),_("code",[v._v("TABLE_ROWS")]),v._v(" 能代替 "),_("code",[v._v("count(*)")]),v._v("吗？")]),v._v(" "),_("p",[v._v("实际上，"),_("code",[v._v("TABLE_ROWS")]),v._v("就是从采样估算得来的，因此它也很不准。有多不准呢，官方文档说误差可能达到 40% 到 50%。"),_("strong",[v._v("所以，show table status 命令显示的行数也不能直接使用。")])]),v._v(" "),_("h1",{attrs:{id:"不同的-count-用法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不同的-count-用法"}},[v._v("#")]),v._v(" 不同的 count 用法")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("select count(?) from t")]),v._v(" 这样的查询语句里面，"),_("code",[v._v("count(*)")]),_("em",[v._v("、"),_("code",[v._v("count(主键 id)")]),v._v("、"),_("code",[v._v("count(字段)")]),v._v("和 "),_("code",[v._v("count(1)")]),v._v("等不同用法的性能，有哪些差别。")])]),v._v(" "),_("p",[v._v("基于 "),_("code",[v._v("InnoDB")]),v._v("引擎，"),_("code",[v._v("count()")]),v._v("是一个聚合函数，对于返回的结果集，一行行地判断，如果 "),_("code",[v._v("count")]),v._v("函数的参数不是 "),_("code",[v._v("NULL")]),v._v("，累计值就加 1，否则不加。最后返回累计值。")]),v._v(" "),_("p",[v._v("所以，"),_("code",[v._v("count(*)")]),v._v("、"),_("code",[v._v("count(主键 id)")]),v._v("和 "),_("code",[v._v("count(1)")]),v._v(" 都表示返回满足条件的结果集的总行数；而 "),_("code",[v._v("count(字段）")]),v._v("，则表示返回满足条件的数据行里面，参数“字段”不为 "),_("code",[v._v("NULL")]),v._v("的总个数。")]),v._v(" "),_("p",[v._v("至于分析性能差别的时候，你可以记住这么几个原则：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("server")]),v._v("层要什么就给什么；")]),v._v(" "),_("li",[_("code",[v._v("InnoDB")]),v._v("只给必要的值；")]),v._v(" "),_("li",[v._v("现在的优化器只优化了 "),_("code",[v._v("count(*)")]),v._v("的语义为“取行数”，其他“显而易见”的优化并没有做。")])]),v._v(" "),_("p",[v._v("这是什么意思呢？接下来，我们就一个个地来看看。")]),v._v(" "),_("p",[_("strong",[v._v("对于 count(主键 id) 来说")]),v._v(" ，"),_("code",[v._v("InnoDB")]),v._v("引擎会遍历整张表，把每一行的 "),_("code",[v._v("id")]),v._v("值都取出来，返回给 "),_("code",[v._v("server")]),v._v("层。"),_("code",[v._v("server")]),v._v("层拿到 "),_("code",[v._v("id")]),v._v("后，判断是不可能为空的，就按行累加。")]),v._v(" "),_("p",[_("strong",[v._v("对于 count(1) 来说")]),v._v(" ，"),_("code",[v._v("InnoDB")]),v._v("引擎遍历整张表，但不取值。"),_("code",[v._v("server")]),v._v("层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。")]),v._v(" "),_("p",[v._v("单看这两个用法的差别的话，你能对比出来，"),_("code",[v._v("count(1)")]),v._v(" 执行得要比"),_("code",[v._v("count(主键 id)")]),v._v(" 快。因为从引擎返回 "),_("code",[v._v("id")]),v._v("会涉及到解析数据行，以及拷贝字段值的操作。")]),v._v(" "),_("p",[_("strong",[v._v("对于 count(字段) 来说")]),v._v(" ：")]),v._v(" "),_("ol",[_("li",[v._v("如果这个“字段”是定义为"),_("code",[v._v("not null")]),v._v("的话，一行行地从记录里面读出这个字段，判断不能为 "),_("code",[v._v("null")]),v._v("，按行累加；")]),v._v(" "),_("li",[v._v("如果这个“字段”定义允许为 "),_("code",[v._v("null")]),v._v("，那么执行的时候，判断到有可能是 "),_("code",[v._v("null")]),v._v("，还要把值取出来再判断一下，不是 "),_("code",[v._v("null")]),v._v("才累加。")])]),v._v(" "),_("p",[v._v("也就是前面的第一条原则，"),_("code",[v._v("server")]),v._v("层要什么字段，"),_("code",[v._v("InnoDB")]),v._v("就返回什么字段。")]),v._v(" "),_("p",[_("strong",[v._v("但是 count(*) 是例外")]),v._v(" ，并不会把全部字段取出来，而是专门做了优化，不取值。"),_("code",[v._v("count(*)")]),v._v("肯定不是 "),_("code",[v._v("null")]),v._v("，按行累加。")]),v._v(" "),_("p",[v._v("当然，"),_("code",[v._v("MySQL")]),v._v("专门针对这个语句进行优化，也不是不可以。但是这种需要专门优化的情况太多了，而且 "),_("code",[v._v("MySQL")]),v._v("已经优化过"),_("code",[v._v("count(*)")]),v._v("了，你直接使用这种用法就可以了。")]),v._v(" "),_("p",[v._v("所以结论是：按照效率排序的话，"),_("code",[v._v("count(字段)<count(主键 id)<count(1)≈count(* )")]),v._v("，所以我建议你，尽量使用 "),_("code",[v._v("count(* )")]),v._v("。")])])}),[],!1,null,null,null);_.default=e.exports}}]);