(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{450:function(_,v,o){"use strict";o.r(v);var e=o(0),c=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"redo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[_._v("#")]),_._v(" redo log")]),_._v(" "),v("p",[v("code",[_._v("redo log")]),_._v(" 是 "),v("code",[_._v("InnoDB")]),_._v(" 引擎特有的日志")]),_._v(" "),v("p",[v("code",[_._v("WAL")]),_._v(" 技术 "),v("code",[_._v("Write-Ahead Logging")]),_._v("：当有一条记录需要更新的时候，"),v("code",[_._v("InnoDB")]),_._v(" 引擎就会先把记录写到 "),v("code",[_._v("redo log")]),_._v(" 里面，并更新内存，这个时候更新就算完成了。同时，"),v("code",[_._v("InnoDB")]),_._v(" 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。")]),_._v(" "),v("p",[v("code",[_._v("InnoDB")]),_._v(" 的 "),v("code",[_._v("redo log")]),_._v(" 是固定大小的，比如可以配置为一组 "),v("code",[_._v("4")]),_._v(" 个文件，每个文件的大小是 "),v("code",[_._v("1GB")]),_._v("，那么总共就可以记录 "),v("code",[_._v("4GB")]),_._v(" 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/d9dca840dd8e479096205344e3ba7ee9.png",alt:"在这里插入图片描述"}})]),_._v(" "),v("p",[v("code",[_._v("write pos")]),_._v(" 是当前记录的位置，一边写一边后移，写到第 "),v("code",[_._v("3")]),_._v(" 号文件末尾后就回到 "),v("code",[_._v("0")]),_._v(" 号文件开头。"),v("code",[_._v("checkpoint")]),_._v(" 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。")]),_._v(" "),v("p",[v("code",[_._v("write pos")]),_._v(" 和 "),v("code",[_._v("checkpoint")]),_._v(" 之间的是还空着的部分，可以用来记录新的操作。如果 "),v("code",[_._v("write pos")]),_._v(" 追上 "),v("code",[_._v("checkpoint")]),_._v("，表示满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 "),v("code",[_._v("checkpoint")]),_._v(" 推进一下。")]),_._v(" "),v("p",[_._v("有了 "),v("code",[_._v("redo log")]),_._v("，"),v("code",[_._v("InnoDB")]),_._v(" 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为"),v("code",[_._v("crash-safe")]),_._v("。")]),_._v(" "),v("h2",{attrs:{id:"redo-log-的写入机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redo-log-的写入机制"}},[_._v("#")]),_._v(" redo log 的写入机制")]),_._v(" "),v("p",[v("strong",[_._v("redo log 存储状态")])]),_._v(" "),v("ol",[v("li",[_._v("存在 "),v("code",[_._v("redo log buffer")]),_._v(" 中，物理上是在"),v("code",[_._v("MySQL")]),_._v("进程内存中")]),_._v(" "),v("li",[_._v("写到磁盘"),v("code",[_._v("（write）")]),_._v("，但是没有持久化"),v("code",[_._v("（fsync）")])]),_._v(" "),v("li",[_._v("持久化到磁盘，对应的是 "),v("code",[_._v("hard disk")])])]),_._v(" "),v("p",[_._v("日志写到 "),v("code",[_._v("redo log buffer")]),_._v(" 是很快的，"),v("code",[_._v("wirte")]),_._v(" 到 "),v("code",[_._v("page cache")]),_._v(" 也差不多，但是持久化到磁盘的速度就慢多了。")]),_._v(" "),v("p",[_._v("为了控制 "),v("code",[_._v("redo log")]),_._v(" 的写入策略，"),v("code",[_._v("InnoDB")]),_._v(" 提供了 "),v("code",[_._v("innodb_flush_log_at_trx_commit")]),_._v(" 参数，它有三种可能取值：")]),_._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("select")]),_._v(" @"),v("span",{pre:!0,attrs:{class:"token variable"}},[_._v("@innodb_flush_log_at_trx_commit")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[_._v("设置为 0 的时候，表示每次事务提交时都只是把 "),v("code",[_._v("redo log")]),_._v(" 留在 "),v("code",[_._v("redo log buffer")]),_._v(" 中 ;")]),_._v(" "),v("p",[_._v("设置为 1 的时候，表示每次事务提交时都将 "),v("code",[_._v("redo log")]),_._v(" 直接持久化到磁盘；")]),_._v(" "),v("p",[_._v("设置为 2 的时候，表示每次事务提交时都只是把 "),v("code",[_._v("redo log")]),_._v(" 写到 "),v("code",[_._v("page cache")]),_._v("。")]),_._v(" "),v("p",[v("code",[_._v("InnoDB")]),_._v(" 有一个后台线程，每隔 1 秒，就会把 "),v("code",[_._v("redo log buffer")]),_._v(" 中的日志，调用 "),v("code",[_._v("write")]),_._v(" 写到文件系统的 "),v("code",[_._v("page cache")]),_._v("，然后调用 "),v("code",[_._v("fsync")]),_._v(" 持久化到磁盘。")]),_._v(" "),v("h1",{attrs:{id:"binlog"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#binlog"}},[_._v("#")]),_._v(" binlog")]),_._v(" "),v("ol",[v("li",[v("p",[v("code",[_._v("redo log")]),_._v(" 是 "),v("code",[_._v("InnoDB")]),_._v(" 引擎特有的；"),v("code",[_._v("binlog")]),_._v(" 是 "),v("code",[_._v("MySQL")]),_._v(" 的 "),v("code",[_._v("Server")]),_._v(" 层实现的，所有引擎都可以使用。")])]),_._v(" "),v("li",[v("p",[v("code",[_._v("redo log")]),_._v(" 是物理日志，记录的是“在某个数据页上做了什么修改”；"),v("code",[_._v("binlog")]),_._v(" 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 "),v("code",[_._v("ID=2")]),_._v(" 这一行的 "),v("code",[_._v("c")]),_._v(" 字段加 1 ”。")])]),_._v(" "),v("li",[v("p",[v("code",[_._v("redo log")]),_._v(" 是循环写的，空间固定会用完；"),v("code",[_._v("binlog")]),_._v(" 是可以追加写入的。“追加写”是指 "),v("code",[_._v("binlog")]),_._v(" 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。")])])]),_._v(" "),v("h2",{attrs:{id:"binlog-的写入机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#binlog-的写入机制"}},[_._v("#")]),_._v(" binlog 的写入机制")]),_._v(" "),v("p",[_._v("事务执行过程中，先把日志写到 "),v("code",[_._v("binlog cache")]),_._v("，事务提交的时候，再把 "),v("code",[_._v("binlog cache")]),_._v(" 写到 "),v("code",[_._v("binlog")]),_._v(" 文件中。")]),_._v(" "),v("p",[_._v("一个事务的 "),v("code",[_._v("binlog")]),_._v(" 是不能被拆开的，因此不论这个事务多大，也要确保一次性写入。这就涉及到了 "),v("code",[_._v("binlog cache")]),_._v(" 的保存问题。")]),_._v(" "),v("p",[_._v("系统给 "),v("code",[_._v("binlog cache")]),_._v(" 分配了一片内存，每个线程一个(每个线程有自己 "),v("code",[_._v("binlog cache")]),_._v("，但是共用同一份 "),v("code",[_._v("binlog")]),_._v(" 文件)，参数 "),v("code",[_._v("binlog_cache_size")]),_._v(" 用于控制单个线程内 "),v("code",[_._v("binlog cache")]),_._v(" 所占内存的大小。如果超过了这个参数规定的大小，就要暂存到磁盘。")]),_._v(" "),v("div",{staticClass:"language-sql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-sql"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("select")]),_._v(" @"),v("span",{pre:!0,attrs:{class:"token variable"}},[_._v("@binlog_cache_size")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br")])]),v("p",[_._v("事务提交的时候，执行器把 "),v("code",[_._v("binlog cache")]),_._v(" 里的完整事务写入到 "),v("code",[_._v("binlog")]),_._v(" 中，并清空 "),v("code",[_._v("binlog cache")]),_._v("。")]),_._v(" "),v("p",[v("code",[_._v("write")]),_._v(":指的就是指把日志写入到文件系统的 "),v("code",[_._v("page cache")]),_._v("，并没有把数据持久化到磁盘，所以速度比较快。\n"),v("code",[_._v("fsync")]),_._v(":才是将数据持久化到磁盘的操作。一般情况下，我们认为 "),v("code",[_._v("fsync")]),_._v(" 才占磁盘的 "),v("code",[_._v("IOPS")]),_._v("。")]),_._v(" "),v("p",[v("code",[_._v("write")]),_._v(" 和 "),v("code",[_._v("fsync")]),_._v(" 的时机，是由参数 "),v("code",[_._v("sync_binlog")]),_._v(" 控制的：")]),_._v(" "),v("p",[v("code",[_._v("sync_binlog=0")]),_._v(" 的时候，表示每次提交事务都只 "),v("code",[_._v("write")]),_._v("，不 "),v("code",[_._v("fsync")]),_._v("；")]),_._v(" "),v("p",[v("code",[_._v("sync_binlog=1")]),_._v(" 的时候，表示每次提交事务都会执行 "),v("code",[_._v("fsync")]),_._v("；")]),_._v(" "),v("p",[v("code",[_._v("sync_binlog=N(N>1)")]),_._v(" 的时候，表示每次提交事务都 "),v("code",[_._v("write")]),_._v("，但累积 "),v("code",[_._v("N")]),_._v(" 个事务后才 "),v("code",[_._v("fsync")]),_._v("。")]),_._v(" "),v("p",[_._v("因此，在出现 "),v("code",[_._v("IO")]),_._v(" 瓶颈的场景里，将 "),v("code",[_._v("sync_binlog")]),_._v(" 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 "),v("code",[_._v("100~1000")]),_._v(" 中的某个数值。")]),_._v(" "),v("p",[_._v("但是，将 "),v("code",[_._v("sync_binlog")]),_._v(" 设置为 "),v("code",[_._v("N")]),_._v("，对应的风险是：如果主机发生异常重启，会丢失最近 "),v("code",[_._v("N")]),_._v(" 个事务的 "),v("code",[_._v("binlog")]),_._v(" 日志。")]),_._v(" "),v("h1",{attrs:{id:"undo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#undo-log"}},[_._v("#")]),_._v(" undo log")]),_._v(" "),v("p",[_._v("是"),v("code",[_._v("innodb")]),_._v("引擎的一种日志，在事务的修改记录之前，会把该记录的原值"),v("code",[_._v("（before image）")]),_._v("先保存起来"),v("code",[_._v("（undo log）")]),_._v("再做修改，以便修改过程中出错能够恢复原值或者其他的事务读取。")]),_._v(" "),v("p",[v("strong",[_._v("作用")]),_._v("\n事务回滚 - 原子性： "),v("code",[_._v("undo log")]),_._v("是为了实现事务的原子性而出现的产物，事务处理的过程中，如果出现了错误或者用户执行"),v("code",[_._v("ROLLBACK")]),_._v("语句，"),v("code",[_._v("MySQL")]),_._v("可以利用"),v("code",[_._v("undo log")]),_._v("中的备份将数据恢复到事务开始之前的状态。")]),_._v(" "),v("p",[_._v("多个行版本控制（"),v("code",[_._v("MVCC")]),_._v("）- 隔离性： "),v("code",[_._v("undo log")]),_._v("在"),v("code",[_._v("MySQL InnoDB")]),_._v("储存引擎中用来实现多版本并发控制，事务未提交之前，当读取的某一行被其他事务锁定时，它可以从"),v("code",[_._v("undo log")]),_._v("中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。")]),_._v(" "),v("p",[v("strong",[_._v("什么时候会生成undo log")])]),_._v(" "),v("p",[_._v("在事务中，进行以下操作，都会创建"),v("code",[_._v("undo log")])]),_._v(" "),v("ol",[v("li",[v("code",[_._v("insert")]),_._v(" 用户定义的表或用户定义的临时表")]),_._v(" "),v("li",[v("code",[_._v("update")]),_._v(" 或者 "),v("code",[_._v("delete")]),_._v(" 用户定义的表或用户定义的临时表")])]),_._v(" "),v("p",[v("a",{attrs:{href:"https://jinglingwang.cn/archives/mysqlundolog",target:"_blank",rel:"noopener noreferrer"}},[_._v("庖丁解InnoDB之UNDO LOG"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/9fba391e83a8475cb2ac98526ec8b912.png",alt:"在这里插入图片描述"}})])])}),[],!1,null,null,null);v.default=c.exports}}]);