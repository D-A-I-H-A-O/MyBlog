(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{451:function(_,v,o){"use strict";o.r(v);var e=o(0),c=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"全局锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[_._v("#")]),_._v(" 全局锁")]),_._v(" "),v("p",[_._v("全局锁就是对整个数据库实例加锁。"),v("code",[_._v("MySQL")]),_._v("提供了一个加全局读锁的方法，命令是"),v("code",[_._v("Flush tables with read lock (FTWRL)")]),_._v("。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。")]),_._v(" "),v("p",[_._v("全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 "),v("code",[_._v("select")]),_._v("出来存成文本。在备份过程中整个库完全处于只读状态。")]),_._v(" "),v("p",[_._v("官方自带的逻辑备份工具是 "),v("code",[_._v("mysqldump")]),_._v("。当 "),v("code",[_._v("mysqldump")]),_._v("使用参数"),v("code",[_._v("–single-transaction")]),_._v("的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 "),v("code",[_._v("MVCC")]),_._v("的支持，这个过程中数据是可以正常更新的。")]),_._v(" "),v("p",[_._v("你一定在疑惑，有了这个功能，为什么还需要 "),v("code",[_._v("FTWRL")]),_._v("呢？**一致性读是好，但前提是引擎要支持这个隔离级别。**比如，对于 "),v("code",[_._v("MyISAM")]),_._v("这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 "),v("code",[_._v("FTWRL")]),_._v(" 命令了。")]),_._v(" "),v("p",[_._v("所以，"),v("code",[_._v("single-transaction")]),_._v("方法只适用于"),v("strong",[_._v("所有的表使用事务引擎的库")]),_._v("。如果有的表使用了不支持事务的引擎，那么备份就只能通过 "),v("code",[_._v("FTWRL")]),_._v("方法。这往往是 "),v("code",[_._v("DBA")]),_._v("要求业务开发人员使用 "),v("code",[_._v("InnoDB")]),_._v("替代 "),v("code",[_._v("MyISAM")]),_._v("的原因之一。")]),_._v(" "),v("blockquote",[v("p",[v("strong",[_._v("set global readonly=true")])])]),_._v(" "),v("p",[v("code",[_._v("readonly")]),_._v("方式也可以让全库进入只读状态，但还是建议使用 "),v("code",[_._v("FTWRL")]),_._v("方式，主要有两个原因：")]),_._v(" "),v("ul",[v("li",[_._v("一是，在有些系统中，"),v("code",[_._v("readonly")]),_._v("的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 "),v("code",[_._v("global")]),_._v("变量的方式影响面更大，不建议你使用。")]),_._v(" "),v("li",[_._v("二是，在异常处理机制上有差异。如果执行 "),v("code",[_._v("FTWRL")]),_._v("命令之后由于客户端发生异常断开，那么 "),v("code",[_._v("MySQL")]),_._v("会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 "),v("code",[_._v("readonly")]),_._v("之后，如果客户端发生异常，则数据库就会一直保持 "),v("code",[_._v("readonly")]),_._v("状态，这样会导致整个库长时间处于不可写状态，风险较高。")])]),_._v(" "),v("p",[_._v("业务的更新不只是增删改数据（"),v("code",[_._v("DML")]),_._v(")，还有可能是加字段等修改表结构的操作（"),v("code",[_._v("DDL")]),_._v("）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。")]),_._v(" "),v("h1",{attrs:{id:"表级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表级锁"}},[_._v("#")]),_._v(" 表级锁")]),_._v(" "),v("p",[v("code",[_._v("MySQL")]),_._v("里面表级别的锁有两种：一种是"),v("strong",[_._v("表锁")]),_._v("，一种是"),v("strong",[_._v("元数据锁")]),_._v("（"),v("code",[_._v("meta data lock，MDL")]),_._v(")。")]),_._v(" "),v("p",[_._v("表锁的语法是 "),v("code",[_._v("lock tables … read/write")]),_._v("。与 "),v("code",[_._v("FTWRL")]),_._v(" 类似，可以用"),v("code",[_._v("unlock tables")]),_._v("主动释放锁，也可以在客户端断开的时候自动释放。需要注意，"),v("code",[_._v("lock tables")]),_._v(" 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。")]),_._v(" "),v("p",[_._v("如果线程 "),v("code",[_._v("A")]),_._v("中执行"),v("code",[_._v("lock tables t1 read, t2 write")]),_._v("；则其他线程写 "),v("code",[_._v("t1")]),_._v("、读写 "),v("code",[_._v("t2")]),_._v(" 的语句都会被阻塞。同时，线程"),v("code",[_._v("A")]),_._v("在执行 "),v("code",[_._v("unlock tables")]),_._v("之前，也只能执行读"),v("code",[_._v("t1")]),_._v("、读写 "),v("code",[_._v("t2")]),_._v("的操作。连写 "),v("code",[_._v("t1")]),_._v("都不允许，自然也不能访问其他表。")]),_._v(" "),v("p",[_._v("在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 "),v("code",[_._v("InnoDB")]),_._v("这种支持行锁的引擎，一般不使用 "),v("code",[_._v("lock tables")]),_._v("命令来控制并发，毕竟锁住整个表的影响面还是太大。")]),_._v(" "),v("p",[_._v("另一类表级的锁是"),v("code",[_._v("MDL（metadata lock)")]),_._v("。"),v("code",[_._v("MDL")]),_._v("不需要显式使用，"),v("strong",[_._v("在访问一个表的时候会被自动加上")]),_._v("。"),v("strong",[_._v("MDL")]),_._v(" 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。")]),_._v(" "),v("p",[_._v("因此，在 "),v("code",[_._v("MySQL 5.5")]),_._v(" 版本中引入了 "),v("code",[_._v("MDL")]),_._v("，当对一个表做增删改查操作的时候，加 "),v("code",[_._v("MDL")]),_._v("读锁；当要对表做结构变更操作的时候，加 "),v("code",[_._v("MDL")]),_._v("写锁。")]),_._v(" "),v("ul",[v("li",[_._v("读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。")]),_._v(" "),v("li",[_._v("读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。")])]),_._v(" "),v("h1",{attrs:{id:"行锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[_._v("#")]),_._v(" 行锁")]),_._v(" "),v("p",[v("code",[_._v("MySQL")]),_._v("的行锁是在引擎层由各个引擎自己实现的，并不是所有的引擎都支持行锁，比如"),v("code",[_._v("MyISAM")]),_._v("引擎就不支持行锁。")]),_._v(" "),v("p",[v("code",[_._v("InnoDB")]),_._v("的行锁：顾名思义，"),v("strong",[_._v("行锁就是针对数据表中行记录的锁")]),_._v("。这很好理解，比如事务 "),v("code",[_._v("A")]),_._v("更新了一行，而这时候事务 "),v("code",[_._v("B")]),_._v(" 也要更新同一行，则必须等事务 "),v("code",[_._v("A")]),_._v("的操作完成后才能进行更新。")]),_._v(" "),v("p",[v("strong",[_._v("在")]),v("code",[_._v("InnoDB")]),_._v(" "),v("strong",[_._v("事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议")]),_._v("。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/2b5dd2f2897d42ec840d2d5140617c3e.png",alt:"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GzYjeBD5-1656472146613)(assets/image-20220629103845-tw8b840.png)]"}})]),_._v(" "),v("h1",{attrs:{id:"死锁和死锁检测"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁和死锁检测"}},[_._v("#")]),_._v(" 死锁和死锁检测")]),_._v(" "),v("p",[_._v("当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。")]),_._v(" "),v("p",[_._v("当出现死锁以后，有两种策略：")]),_._v(" "),v("ul",[v("li",[_._v("一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 "),v("code",[_._v("innodb_lock_wait_timeout")]),_._v("来设置。")]),_._v(" "),v("li",[_._v("另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 "),v("code",[_._v("innodb_deadlock_detect")]),_._v("设置为 "),v("code",[_._v("on")]),_._v("，表示开启这个逻辑。")])]),_._v(" "),v("p",[_._v("在 "),v("code",[_._v("InnoDB")]),_._v("中，"),v("code",[_._v("innodb_lock_wait_timeout")]),_._v(" 的默认值是 "),v("code",[_._v("50s")]),_._v("，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 "),v("code",[_._v("50s")]),_._v(" 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。")]),_._v(" "),v("p",[_._v("但是，我们又不可能直接把这个时间设置成一个很小的值，比如 "),v("code",[_._v("1s")]),_._v("。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。")]),_._v(" "),v("p",[_._v("所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 "),v("code",[_._v("innodb_deadlock_detect")]),_._v("的默认值本身就是 "),v("code",[_._v("on")]),_._v("。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。")]),_._v(" "),v("p",[_._v("怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，死锁检测要耗费大量的 "),v("code",[_._v("CPU")]),_._v("资源。")]),_._v(" "),v("p",[v("strong",[_._v("一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉")]),_._v("。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。")]),_._v(" "),v("p",[v("strong",[_._v("另一个思路是控制并发度")]),_._v("。根据上面的分析，你会发现如果并发能够控制住，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是，你会很快发现这个方法不太可行，因为客户端很多。我见过一个应用，有 600 个客户端，这样即使每个客户端控制到只有 5 个并发线程，汇总到数据库服务端以后，峰值并发数也可能要达到 3000。")]),_._v(" "),v("p",[_._v("因此，这个并发控制要做在数据库服务端。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 "),v("code",[_._v("MySQL")]),_._v("源码的人，也可以做在 "),v("code",[_._v("MySQL")]),_._v("里面。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 "),v("code",[_._v("InnoDB")]),_._v("内部就不会有大量的死锁检测工作了。")])])}),[],!1,null,null,null);v.default=c.exports}}]);