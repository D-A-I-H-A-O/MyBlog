(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{448:function(v,_,s){"use strict";s.r(_);var e=s(0),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"索引的常见模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引的常见模型"}},[v._v("#")]),v._v(" 索引的常见模型")]),v._v(" "),_("h2",{attrs:{id:"哈希表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哈希表"}},[v._v("#")]),v._v(" 哈希表")]),v._v(" "),_("p",[v._v("哈希表是一种以键 - 值（"),_("code",[v._v("key-value")]),v._v("）存储数据的结构，我们只要输入待查找的值即 "),_("code",[v._v("key")]),v._v("，就可以找到其对应的值即 "),_("code",[v._v("Value")]),v._v("。哈希的思路很简单，把值放在数组里，用一个哈希函数把 "),_("code",[v._v("key")]),v._v("换算成一个确定的位置，然后把 "),_("code",[v._v("value")]),v._v("放在数组的这个位置。")]),v._v(" "),_("p",[_("strong",[v._v("哈希表这种结构适用于只有等值查询的场景")]),v._v(" ，比如 "),_("code",[v._v("Memcached")]),v._v("及其他一些 "),_("code",[v._v("NoSQL")]),v._v("引擎。")]),v._v(" "),_("h2",{attrs:{id:"有序数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有序数组"}},[v._v("#")]),v._v(" 有序数组")]),v._v(" "),_("p",[_("strong",[v._v("有序数组在等值查询和范围查询场景中的性能就都非常优秀")]),v._v("，但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。")]),v._v(" "),_("p",[v._v("所以， "),_("strong",[v._v("有序数组索引只适用于静态存储引擎")]),v._v(" ，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。")]),v._v(" "),_("h2",{attrs:{id:"搜索树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#搜索树"}},[v._v("#")]),v._v(" 搜索树")]),v._v(" "),_("p",[v._v("二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。")]),v._v(" "),_("p",[v._v("树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。")]),v._v(" "),_("h1",{attrs:{id:"innodb-的索引模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#innodb-的索引模型"}},[v._v("#")]),v._v(" InnoDB 的索引模型")]),v._v(" "),_("p",[v._v("在 "),_("code",[v._v("InnoDB")]),v._v("中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为"),_("strong",[v._v("索引组织表")]),v._v("。又因为前面我们提到的，"),_("code",[v._v("InnoDB")]),v._v("使用了"),_("code",[v._v("B+")]),v._v(" 树索引模型，所以数据都是存储在"),_("code",[v._v("B+")]),v._v("树中的。")]),v._v(" "),_("p",[v._v("每一个索引在"),_("code",[v._v("InnoDB")]),v._v("里面对应一棵"),_("code",[v._v("B+")]),v._v(" 树。")]),v._v(" "),_("p",[v._v("假设，我们有一个主键列为 "),_("code",[v._v("ID")]),v._v("的表，表中有字段 "),_("code",[v._v("k")]),v._v("，并且在"),_("code",[v._v("k")]),v._v("上有索引。")]),v._v(" "),_("p",[v._v("这个表的建表语句是：")]),v._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[v._v("mysql"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v(">")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("create")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("table")]),v._v(" T"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("\nid "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("int")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("primary")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("key")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" \nk "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("int")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("not")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token boolean"}},[v._v("null")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" \nname "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("varchar")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("16")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("index")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("k"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("engine")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("InnoDB")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br")])]),_("blockquote",[_("p",[v._v("索引类型分为主键索引和非主键索引")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("主键索引的叶子节点存的是整行数据。在 "),_("code",[v._v("InnoDB")]),v._v("里，主键索引也被称为聚簇索引"),_("code",[v._v("（clustered index）")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("非主键索引的叶子节点内容是主键的值。在 "),_("code",[v._v("InnoDB")]),v._v("里，非主键索引也被称为二级索引"),_("code",[v._v("（secondary index）")]),v._v("。")])])]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("基于主键索引和普通索引的查询有什么区别")])])]),v._v(" "),_("p",[v._v("如果语句是"),_("code",[v._v("select * from T where ID=500")]),v._v("，即主键查询方式，则只需要搜索"),_("code",[v._v("ID")]),v._v("这棵"),_("code",[v._v("B+")]),v._v(" 树；")]),v._v(" "),_("p",[v._v("如果语句是"),_("code",[v._v("select * from T where k=5")]),v._v("，即普通索引查询方式，则需要先搜索 "),_("code",[v._v("k")]),v._v("索引树，得到 "),_("code",[v._v("ID")]),v._v("的值为 "),_("code",[v._v("500")]),v._v("，再到 "),_("code",[v._v("ID")]),v._v("索引树搜索一次。这个过程称为"),_("strong",[v._v("回表")]),v._v("。")]),v._v(" "),_("p",[v._v("也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。")]),v._v(" "),_("h1",{attrs:{id:"索引维护"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引维护"}},[v._v("#")]),v._v(" 索引维护")]),v._v(" "),_("p",[_("code",[v._v("B+")]),v._v("树为了维护索引有序性，在插入新值的时候需要做必要的维护。如果新插入的值所在的数据页已经满了，根据"),_("code",[v._v("B+")]),v._v(" 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为"),_("strong",[v._v("页分裂")]),v._v("。在这种情况下，性能自然会受影响。")]),v._v(" "),_("p",[v._v("除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。")]),v._v(" "),_("p",[v._v("当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。")]),v._v(" "),_("blockquote",[_("p",[v._v("建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。")])]),v._v(" "),_("p",[v._v("自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： "),_("code",[v._v("NOT NULL PRIMARY KEY AUTO_INCREMENT。")]),v._v("插入新记录的时候可以不指定 "),_("code",[v._v("ID")]),v._v("的值，系统会获取当前 "),_("code",[v._v("ID")]),v._v("最大值加 "),_("code",[v._v("1")]),v._v(" 作为下一条记录的 "),_("code",[v._v("ID")]),v._v("值")]),v._v(" "),_("p",[v._v("而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。")]),v._v(" "),_("p",[v._v("除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？")]),v._v(" "),_("p",[v._v("由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（"),_("code",[v._v("bigint")]),v._v("）则是 8 个字节。")]),v._v(" "),_("p",[_("strong",[v._v("显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。")])]),v._v(" "),_("p",[v._v("所以，"),_("strong",[v._v("从性能和存储空间方面考量，自增主键往往是更合理的选择")]),v._v("。")]),v._v(" "),_("h1",{attrs:{id:"覆盖索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引"}},[v._v("#")]),v._v(" 覆盖索引")]),v._v(" "),_("p",[v._v('在查询里面，索引已经"覆盖"了查询字段，称之为"覆盖索引"。')]),v._v(" "),_("p",[_("strong",[v._v("覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。")])]),v._v(" "),_("p",[v._v("基于上面覆盖索引的说明，我们来讨论一个问题："),_("strong",[v._v("在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？")])]),v._v(" "),_("p",[v._v("假设这个市民表的定义是这样的：")]),v._v(" "),_("div",{staticClass:"language-r line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-r"}},[_("code",[v._v("CREATE TABLE `tuser` "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("\n  `id` int"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("11")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" NOT "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("NULL")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  `id_card` varchar"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("32")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" DEFAULT "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("NULL")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  `name` varchar"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("32")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" DEFAULT "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("NULL")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  `age` int"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("11")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" DEFAULT "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("NULL")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  `ismale` tinyint"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" DEFAULT "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("NULL")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  PRIMARY KEY "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("`id`"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  KEY `id_card` "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("`id_card`"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("\n  KEY `name_age` "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("`name`"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("`age`"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" ENGINE"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v("InnoDB\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br"),_("span",{staticClass:"line-number"},[v._v("9")]),_("br"),_("span",{staticClass:"line-number"},[v._v("10")]),_("br")])]),_("p",[v._v("我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？")]),v._v(" "),_("p",[v._v("如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个"),_("strong",[v._v("高频请求上用到覆盖索引")]),v._v("，"),_("strong",[v._v("不再需要回表查整行记录，减少语句的执行时间")]),v._v("。")]),v._v(" "),_("p",[v._v("当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 "),_("code",[v._v("DBA")]),v._v("，或者称为业务数据架构师的工作。")]),v._v(" "),_("h1",{attrs:{id:"最左前缀原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最左前缀原则"}},[v._v("#")]),v._v(" 最左前缀原则")]),v._v(" "),_("p",[v._v("只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 "),_("code",[v._v("N")]),v._v("个字段，也可以是字符串索引的最左 "),_("code",[v._v("M")]),v._v("个字符。")]),v._v(" "),_("blockquote",[_("p",[_("strong",[v._v("在建立联合索引的时候，如何安排索引内的字段顺序")])])]),v._v(" "),_("p",[v._v("评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了"),_("code",[v._v("(a,b)")]),v._v("这个联合索引后，一般就不需要单独在"),_("code",[v._v("a")]),v._v(" 上建立索引了。因此，"),_("strong",[v._v("第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。")])]),v._v(" "),_("p",[v._v("那么，如果既有联合查询，又有基于 "),_("code",[v._v("a、b")]),v._v("各自的查询呢？查询条件里面只有"),_("code",[v._v("b")]),v._v("的语句，是无法使用"),_("code",[v._v("(a,b)")]),v._v("这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护"),_("code",[v._v("(a,b)")]),v._v("、"),_("code",[v._v("(b)")]),v._v("这两个索引。")]),v._v(" "),_("p",[v._v("这时候，我们要"),_("strong",[v._v("考虑的原则就是空间")]),v._v("了。比如上面这个市民表的情况，"),_("code",[v._v("name")]),v._v("字段是比 "),_("code",[v._v("age")]),v._v("字段大的 ，那我就建议你创建一个"),_("code",[v._v("（name,age)")]),v._v("的联合索引和一个 ("),_("code",[v._v("age")]),v._v(") 的单字段索引。")]),v._v(" "),_("h1",{attrs:{id:"索引下推"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引下推"}},[v._v("#")]),v._v(" 索引下推")]),v._v(" "),_("p",[v._v("索引下推("),_("code",[v._v("Index Condition Pushdown")]),v._v("，简称"),_("code",[v._v("ICP")]),v._v(")，是"),_("code",[v._v("MySQL5.6")]),v._v("版本的新特性，它能减少回表查询次数，提高查询效率。")]),v._v(" "),_("p",[v._v("索引下推的"),_("strong",[v._v("下推")]),v._v("其实就是指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。")]),v._v(" "),_("p",[v._v("在没有使用"),_("code",[v._v("ICP")]),v._v("的情况下，"),_("code",[v._v("MySQL")]),v._v("的查询：")]),v._v(" "),_("ul",[_("li",[v._v("存储引擎读取索引记录；")]),v._v(" "),_("li",[v._v("根据索引中的主键值，定位并读取完整的行记录；")]),v._v(" "),_("li",[v._v("存储引擎把记录交给"),_("code",[v._v("Server")]),v._v("层去检测该记录是否满足"),_("code",[v._v("WHERE")]),v._v("条件。")])]),v._v(" "),_("p",[v._v("使用"),_("code",[v._v("ICP")]),v._v("的情况下，查询过程：")]),v._v(" "),_("ul",[_("li",[v._v("存储引擎读取索引记录（不是完整的行记录）；")]),v._v(" "),_("li",[v._v("判断"),_("code",[v._v("WHERE")]),v._v("条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；")]),v._v(" "),_("li",[v._v("条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；")]),v._v(" "),_("li",[v._v("存储引擎把记录交给"),_("code",[v._v("Server")]),v._v("层，"),_("code",[v._v("Server")]),v._v("层检测该记录是否满足"),_("code",[v._v("WHERE")]),v._v("条件的其余部分。")])]),v._v(" "),_("p",[v._v("对于"),_("code",[v._v("tuser")]),v._v("表有联合索引"),_("code",[v._v("（name,age）")]),v._v(",现有需求：检索出表中名字第一个字是张，而且年龄是10岁的所有用户")]),v._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("select")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("*")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("from")]),v._v(" tuser "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("where")]),v._v(" name "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("like")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v("'张%'")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("and")]),v._v(" age"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("10")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("流程：")]),v._v(" "),_("p",[v._v("1、最左匹配原则搜索索引树，用"),_("code",[v._v("“张”")]),v._v("找到第一个满足条件的记录")]),v._v(" "),_("p",[v._v("2、在"),_("code",[v._v("MySQL 5.6")]),v._v("之前，没有使用"),_("code",[v._v("ICP")]),v._v("，存储引擎根据通过联合索引找到"),_("code",[v._v("name like '张%'")]),v._v(" ，逐一进行回表扫描，去聚簇索引找到完整的行记录，"),_("code",[v._v("server")]),v._v("层再对数据根据"),_("code",[v._v("age=10")]),v._v("进行筛选。")]),v._v(" "),_("p",[v._v("3、而"),_("code",[v._v("MySQL 5.6")]),v._v("以后，使用"),_("code",[v._v("ICP")]),v._v("， 存储引擎根据"),_("code",[v._v("（name，age）")]),v._v("联合索引，找到"),_("code",[v._v("name like '张%'")]),v._v("，由于联合索引中包含"),_("code",[v._v("age")]),v._v("列，所以存储引擎直接再联合索引里按照"),_("code",[v._v("age=10")]),v._v("过滤。按照过滤后的数据再一一进行回表扫描。")]),v._v(" "),_("h1",{attrs:{id:"索引下推使用条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引下推使用条件"}},[v._v("#")]),v._v(" 索引下推使用条件")]),v._v(" "),_("ul",[_("li",[v._v("只能用于"),_("code",[v._v("range")]),v._v("、 "),_("code",[v._v("ref")]),v._v("、 "),_("code",[v._v("eq_ref")]),v._v("、"),_("code",[v._v("ref_or_null")]),v._v("访问方法；")]),v._v(" "),_("li",[v._v("只能用于"),_("code",[v._v("InnoDB")]),v._v("和 "),_("code",[v._v("MyISAM")]),v._v("存储引擎及其分区表；")]),v._v(" "),_("li",[v._v("对"),_("code",[v._v("InnoDB")]),v._v("存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）;")])]),v._v(" "),_("blockquote",[_("p",[v._v("索引下推的目的是为了减少回表次数，也就是要减少IO操作。对于"),_("code",[v._v("InnoDB")]),v._v("的"),_("strong",[v._v("聚簇索引")]),v._v("来说，数据和索引是在一起的，不存在回表这一说。")])]),v._v(" "),_("ul",[_("li",[v._v("引用了子查询的条件不能下推；")]),v._v(" "),_("li",[v._v("引用了存储函数的条件不能下推，因为存储引擎无法调用存储函数。")])]),v._v(" "),_("h1",{attrs:{id:"相关系统参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#相关系统参数"}},[v._v("#")]),v._v(" 相关系统参数")]),v._v(" "),_("p",[v._v("索引条件下推默认是开启的，可以使用系统参数"),_("code",[v._v("optimizer_switch")]),v._v("来控制器是否开启。")]),v._v(" "),_("p",[v._v("查看默认状态：")]),v._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("select")]),v._v(" @"),_("span",{pre:!0,attrs:{class:"token variable"}},[v._v("@optimizer_switch")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("切换状态：")]),v._v(" "),_("div",{staticClass:"language-sql line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("set")]),v._v(" optimizer_switch"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"index_condition_pushdown=off"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("set")]),v._v(" optimizer_switch"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"index_condition_pushdown=on"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])]),_("h1",{attrs:{id:"普通索引和唯一索引的选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#普通索引和唯一索引的选择"}},[v._v("#")]),v._v(" 普通索引和唯一索引的选择")]),v._v(" "),_("p",[v._v("从查询和更新语句的性能影响来分析")]),v._v(" "),_("blockquote",[_("p",[v._v("查询")])]),v._v(" "),_("ul",[_("li",[v._v("对于普通索引，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录")]),v._v(" "),_("li",[v._v("对于唯一索引，由于索引定义了唯一性，查找到满足条件的记录后，就会停止继续查找")])]),v._v(" "),_("p",[_("code",[v._v("InnoDB")]),v._v("的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 "),_("code",[v._v("InnoDB")]),v._v("中，每个数据页的大小默认是"),_("code",[v._v("16KB。")])]),v._v(" "),_("p",[v._v("因为引擎是按页读写的，所以说，当找到满足条件的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。")]),v._v(" "),_("p",[v._v("当然，如果这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。")]),v._v(" "),_("p",[v._v("但是，我们之前计算过，对于整型字段，一个数据页可以放近千个 "),_("code",[v._v("key")]),v._v("，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的 "),_("code",[v._v("CPU")]),v._v("来说可以忽略不计。")]),v._v(" "),_("blockquote",[_("p",[v._v("更新")])]),v._v(" "),_("p",[v._v("第一种情况是， "),_("strong",[v._v("这个记录要更新的目标页在内存中")]),v._v(" 。这时，"),_("code",[v._v("InnoDB")]),v._v("的处理流程如下：")]),v._v(" "),_("ul",[_("li",[v._v("对于唯一索引来说，找到满足条件之间的位置，判断到没有冲突，插入这个值，语句执行结束；")]),v._v(" "),_("li",[v._v("对于普通索引来说，找到满足条件之间的位置，插入这个值，语句执行结束。")])]),v._v(" "),_("p",[v._v("这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 "),_("code",[v._v("CPU")]),v._v("时间。")]),v._v(" "),_("p",[v._v("但，这不是我们关注的重点。")]),v._v(" "),_("p",[v._v("第二种情况是， "),_("strong",[v._v("这个记录要更新的目标页不在内存中")]),v._v(" 。这时，"),_("code",[v._v("InnoDB")]),v._v("的处理流程如下：")]),v._v(" "),_("ul",[_("li",[v._v("对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；")]),v._v(" "),_("li",[v._v("对于普通索引来说，则是将更新记录在 "),_("code",[v._v("change buffer")]),v._v("，语句执行就结束了。")])]),v._v(" "),_("p",[v._v("将数据从磁盘读入内存涉及随机 "),_("code",[v._v("IO")]),v._v("的访问，是数据库里面成本最高的操作之一。"),_("code",[v._v("change buffer")]),v._v("因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。")]),v._v(" "),_("blockquote",[_("p",[v._v("当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，"),_("code",[v._v("InooDB")]),v._v("会将这些更新操作缓存在 "),_("code",[v._v("change buffer")]),v._v(" 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 "),_("code",[v._v("change buffer")]),v._v(" 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。")]),v._v(" "),_("p",[v._v("需要说明的是，虽然名字叫作 "),_("code",[v._v("change buffer")]),v._v("，实际上它是可以持久化的数据。也就是说，"),_("code",[v._v("change buffer")]),v._v("在内存中有拷贝，也会被写入到磁盘上。")]),v._v(" "),_("p",[v._v("将"),_("code",[v._v("change buffer")]),v._v(" 中的操作应用到原数据页，得到最新结果的过程称为 "),_("code",[v._v("merge")]),v._v("。除了访问这个数据页会触发 "),_("code",[v._v("merge")]),v._v("外，系统有后台线程会定期 "),_("code",[v._v("merge")]),v._v("。在数据库正常关闭（"),_("code",[v._v("shutdown")]),v._v("）的过程中，也会执行 "),_("code",[v._v("merge")]),v._v("操作。")]),v._v(" "),_("p",[v._v("显然，如果能够将更新操作先记录在 "),_("code",[v._v("change buffer")]),v._v("，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 "),_("code",[v._v("buffer pool")]),v._v("的，所以这种方式还能够避免占用内存，提高内存利用率。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);