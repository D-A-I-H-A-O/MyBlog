(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{475:function(v,_,e){"use strict";e.r(_);var a=e(0),t=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("table",[_("thead",[_("tr",[_("th",[v._v("作用")]),v._v(" "),_("th",[v._v("关键字")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("访问控制")]),v._v(" "),_("td",[v._v("private、protected、public")])]),v._v(" "),_("tr",[_("td",[v._v("类，方法和变量修饰符")]),v._v(" "),_("td",[v._v("abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、volatile")])]),v._v(" "),_("tr",[_("td",[v._v("程序控制")]),v._v(" "),_("td",[v._v("break、continue、return、do、while、if、else、for、instanceof、switch、case、default")])]),v._v(" "),_("tr",[_("td",[v._v("错误处理")]),v._v(" "),_("td",[v._v("try、catch、throw、throws、finally")])]),v._v(" "),_("tr",[_("td",[v._v("包相关")]),v._v(" "),_("td",[v._v("import、package")])]),v._v(" "),_("tr",[_("td",[v._v("基本类型")]),v._v(" "),_("td",[v._v("boolean、byte\t、char、double、float、int、long、short、null、true、false")])]),v._v(" "),_("tr",[_("td",[v._v("变量引用")]),v._v(" "),_("td",[v._v("super、this、void")])]),v._v(" "),_("tr",[_("td",[v._v("保留字")]),v._v(" "),_("td",[v._v("goto、const")])])])]),v._v(" "),_("h1",{attrs:{id:"访问控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#访问控制"}},[v._v("#")]),v._v(" 访问控制")]),v._v(" "),_("h2",{attrs:{id:"private-私有的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#private-私有的"}},[v._v("#")]),v._v(" private 私有的")]),v._v(" "),_("p",[_("code",[v._v("private")]),v._v(" 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。 只能在声明 "),_("code",[v._v("private")]),v._v("（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。")]),v._v(" "),_("h2",{attrs:{id:"protected-受保护的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#protected-受保护的"}},[v._v("#")]),v._v(" protected 受保护的")]),v._v(" "),_("p",[_("code",[v._v("protected")]),v._v(" 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。可以在声明 "),_("code",[v._v("protected")]),v._v(" 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。")]),v._v(" "),_("h2",{attrs:{id:"public-公共的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#public-公共的"}},[v._v("#")]),v._v(" public 公共的")]),v._v(" "),_("p",[_("code",[v._v("public")]),v._v(" 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 可在其他任何类或包中引用 "),_("code",[v._v("public")]),v._v(" 类、方法或字段")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("访问权限")]),v._v(" "),_("th",[v._v("当前类")]),v._v(" "),_("th",[v._v("包")]),v._v(" "),_("th",[v._v("子类")]),v._v(" "),_("th",[v._v("其他包")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("public")]),v._v(" "),_("td",[v._v("∨")]),v._v(" "),_("td",[v._v("∨")]),v._v(" "),_("td",[v._v("∨")]),v._v(" "),_("td",[v._v("∨")])]),v._v(" "),_("tr",[_("td",[v._v("protect")]),v._v(" "),_("td",[v._v("∨")]),v._v(" "),_("td",[v._v("∨")]),v._v(" "),_("td",[v._v("∨")]),v._v(" "),_("td",[v._v("×")])]),v._v(" "),_("tr",[_("td",[v._v("default")]),v._v(" "),_("td",[v._v("∨")]),v._v(" "),_("td",[v._v("∨")]),v._v(" "),_("td",[v._v("×")]),v._v(" "),_("td",[v._v("×")])]),v._v(" "),_("tr",[_("td",[v._v("private")]),v._v(" "),_("td",[v._v("∨")]),v._v(" "),_("td",[v._v("×")]),v._v(" "),_("td",[v._v("×")]),v._v(" "),_("td",[v._v("×")])])])]),v._v(" "),_("h1",{attrs:{id:"类、方法和变量修饰符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类、方法和变量修饰符"}},[v._v("#")]),v._v(" 类、方法和变量修饰符")]),v._v(" "),_("h2",{attrs:{id:"abstract-声明抽象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#abstract-声明抽象"}},[v._v("#")]),v._v(" abstract 声明抽象")]),v._v(" "),_("p",[_("code",[v._v("abstract")]),v._v("关键字可以修改类或方法。"),_("code",[v._v("abstract")]),v._v("类可以扩展（增加子类），但不能直接实例化。"),_("code",[v._v("abstract")]),v._v("方法不在声明它的类中实现，但必须在某个子类中重写。采用 "),_("code",[v._v("abstract")]),v._v("方法的类本来就是抽象类，并且必须声明为"),_("code",[v._v("abstract")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"class类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#class类"}},[v._v("#")]),v._v(" class类")]),v._v(" "),_("p",[_("code",[v._v("class")]),v._v(" 关键字用来声明新的 "),_("code",[v._v("Java")]),v._v(" 类，该类是相关变量和/或方法的集合。类是面向对象的程序设计方法的基本构造单位。类通常代表某种实际实体，如几何形状或人。类是对象的模板。每个对象都是类的一个实例。要使用类，通常使用 "),_("code",[v._v("new")]),v._v(" 操作符将类的对象实例化，然后调用类的方法来访问类的功能。")]),v._v(" "),_("h2",{attrs:{id:"extends-继承、扩展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#extends-继承、扩展"}},[v._v("#")]),v._v(" extends 继承、扩展")]),v._v(" "),_("p",[_("code",[v._v("extends")]),v._v(" 关键字用在 "),_("code",[v._v("class")]),v._v(" 或 "),_("code",[v._v("interface")]),v._v(" 声明中，用于指示所声明的类或接口是其名称后跟有 "),_("code",[v._v("extends")]),v._v(" 关键字的类或接口的子类。子类继承父类的所有 "),_("code",[v._v("public")]),v._v(" 和 "),_("code",[v._v("protected")]),v._v(" 变量和方法（但是不包括构造函数）。 子类可以重写父类的任何非 "),_("code",[v._v("final")]),v._v(" 方法。一个类只能扩展一个其他类。")]),v._v(" "),_("p",[_("code",[v._v("extends")]),v._v(" 关键字用在 "),_("code",[v._v("class")]),v._v(" 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 "),_("code",[v._v("extends")]),v._v(" 关键字的类或接口的子类")]),v._v(" "),_("h2",{attrs:{id:"final-最终、不可改变"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#final-最终、不可改变"}},[v._v("#")]),v._v(" final 最终、不可改变")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("Java")]),v._v("中，"),_("code",[v._v("final")]),v._v("关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。"),_("code",[v._v("final")]),v._v("方法在编译阶段绑定，称为静态绑定"),_("code",[v._v("(static binding)")]),v._v("。下面就从这四个方面来了解一下"),_("code",[v._v("final")]),v._v("关键字的基本用法。")]),v._v(" "),_("p",[v._v("1、修饰类")]),v._v(" "),_("p",[v._v("当用"),_("code",[v._v("final")]),v._v("修饰一个类时，表明这个类不能被继承，不能有子类。也就是说，如果一个类你永远不会让他被继承，就可以用"),_("code",[v._v("final")]),v._v("进行修饰。"),_("code",[v._v("final")]),v._v("类中的成员变量可以根据需要设为"),_("code",[v._v("final")]),v._v("，但是要注意"),_("code",[v._v("final")]),v._v("类中的所有成员方法都会被隐式地指定为"),_("code",[v._v("final")]),v._v("方法。")]),v._v(" "),_("p",[v._v("2、修饰方法")]),v._v(" "),_("p",[v._v("下面这段话摘自《Java编程思想》：")]),v._v(" "),_("blockquote",[_("p",[v._v("使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。")])]),v._v(" "),_("p",[v._v("因此，如果只有在想明确禁止 该方法在子类中被覆盖的情况下才将方法设置为"),_("code",[v._v("final")]),v._v("的。")]),v._v(" "),_("p",[v._v("还有就是，类的"),_("code",[v._v("private")]),v._v("方法会隐式地被指定为"),_("code",[v._v("final")]),v._v("方法。")]),v._v(" "),_("p",[v._v("3、修饰变量")]),v._v(" "),_("p",[v._v("修饰变量是"),_("code",[v._v("final")]),v._v("用得最多的地方。")]),v._v(" "),_("p",[v._v("对于一个"),_("code",[v._v("final")]),v._v("变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。引用变量被"),_("code",[v._v("final")]),v._v("修饰之后，虽然不能再指向其他对象，但是它指向的对象的内容是可变的。")]),v._v(" "),_("p",[v._v("4、final参数")]),v._v(" "),_("p",[v._v("当函数参数为"),_("code",[v._v("final")]),v._v("类型时，你可以读取使用该参数，但是无法改变该参数的值或者引用指向。道理同"),_("code",[v._v("final")]),v._v("变量。")]),v._v(" "),_("p",[v._v("概括起来就是：")]),v._v(" "),_("p",[v._v("在A类是声明为"),_("code",[v._v("final")]),v._v("类型的方法，那么不能在子类里被覆盖；")]),v._v(" "),_("p",[v._v("如果A类被声明为"),_("code",[v._v("final")]),v._v("类型的类，那么B类不能继承A类；")]),v._v(" "),_("p",[v._v("如果成员变量声明为"),_("code",[v._v("final")]),v._v("类型，那么成员变量不能被修改；")]),v._v(" "),_("p",[v._v("注意：")]),v._v(" "),_("p",[v._v("1、一个类不能同时是 "),_("code",[v._v("abstract")]),v._v(" 又是 "),_("code",[v._v("final")]),v._v("。"),_("code",[v._v("abstract")]),v._v(" 意味着必须扩展类，"),_("code",[v._v("final")]),v._v(" 意味着不能扩展类。一个方法不能同时是 "),_("code",[v._v("abstract")]),v._v(" 又是 "),_("code",[v._v("final")]),v._v("。"),_("code",[v._v("abstract")]),v._v(" 意味着必须重写方法，"),_("code",[v._v("final")]),v._v(" 意味着不能重写方法。两者是相互矛盾的。")]),v._v(" "),_("p",[v._v("2、当用"),_("code",[v._v("final")]),v._v("作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且"),_("code",[v._v("final")]),v._v("变量一旦被初始化赋值之后，就不能再被赋值了。")]),v._v(" "),_("p",[v._v("3、"),_("code",[v._v("final")]),v._v("变量和普通变量的区别。当"),_("code",[v._v("final")]),v._v("变量是基本数据类型以及"),_("code",[v._v("String")]),v._v("类型时，如果在编译期间能知道它的确切值，则编译器会进行优化，会把它当做编译期常量使用。也就是说在用到该"),_("code",[v._v("final")]),v._v("变量的地方，相当于直接访问的这个常量，不需要在运行时确定。这种和C语言中的宏替换有点像。而普通变量在编译时，确定不了自身的值，需要在运行时才能知道。")]),v._v(" "),_("p",[v._v("4、局部内部类和匿名内部类只能访问局部"),_("code",[v._v("final")]),v._v("变量。因为这里的局部变量，需要在编译阶段便需要确定下来的。也就是说，如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。")]),v._v(" "),_("h2",{attrs:{id:"implements实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#implements实现"}},[v._v("#")]),v._v(" implements实现")]),v._v(" "),_("p",[_("code",[v._v("implements")]),v._v(" 关键字在 "),_("code",[v._v("class")]),v._v(" 声明中使用，以指示所声明的类提供了在 "),_("code",[v._v("implements")]),v._v(" 关键字后面的名称所指定的接口中所声明的所有方法的实现。类必须提供在接口中所声明的所有方法的实现。一个类可以实现多个接口。")]),v._v(" "),_("h2",{attrs:{id:"interface-接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#interface-接口"}},[v._v("#")]),v._v(" interface 接口")]),v._v(" "),_("p",[_("code",[v._v("interface")]),v._v(" 关键字用来声明新的 "),_("code",[v._v("Java")]),v._v(" 接口，接口是方法的集合。")]),v._v(" "),_("p",[v._v("接口是 "),_("code",[v._v("Java")]),v._v(" 语言的一项强大功能。任何类都可声明它实现一个或多个接口，这意味着它实现了在这些接口中所定义的所有方法。")]),v._v(" "),_("p",[v._v("实现了接口的任何类都必须提供在该接口中的所有方法的实现。一个类可以实现多个接口。")]),v._v(" "),_("h2",{attrs:{id:"native-本地"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#native-本地"}},[v._v("#")]),v._v(" native 本地")]),v._v(" "),_("p",[_("code",[v._v("native")]),v._v(" 关键字可以应用于方法，以指示该方法是用"),_("code",[v._v("Java")]),v._v("以外的语言实现的，方法对应的实现不是在当前文件，而是在用其他语言（如"),_("code",[v._v("C和C++")]),v._v("）实现的文件中。。")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v("不是完美的，"),_("code",[v._v("Java")]),v._v("的不足除了体现在运行速度上要比传统的"),_("code",[v._v("C++")]),v._v("慢许多之外，"),_("code",[v._v("Java")]),v._v("无法直接访问到操作系统底层（如系统硬件等)，为此"),_("code",[v._v("Java")]),v._v("使用"),_("code",[v._v("native")]),v._v("方法来扩展"),_("code",[v._v("Java")]),v._v("程序的功能。")]),v._v(" "),_("p",[v._v("可以将"),_("code",[v._v("native")]),v._v("方法比作"),_("code",[v._v("Java")]),v._v("程序同"),_("code",[v._v("Ｃ程序")]),v._v("的接口，其实现步骤：")]),v._v(" "),_("p",[v._v("１、在"),_("code",[v._v("Java")]),v._v("中声明"),_("code",[v._v("native()")]),v._v("方法，然后编译；")]),v._v(" "),_("p",[v._v("２、用"),_("code",[v._v("javah")]),v._v("产生一个"),_("code",[v._v(".h")]),v._v("文件；")]),v._v(" "),_("p",[v._v("３、写一个"),_("code",[v._v(".cpp")]),v._v("文件实现"),_("code",[v._v("native")]),v._v("导出方法，其中需要包含第二步产生的"),_("code",[v._v(".h")]),v._v("文件（注意其中又包含了"),_("code",[v._v("JDK")]),v._v("带的"),_("code",[v._v("jni.h")]),v._v("文件）；")]),v._v(" "),_("p",[v._v("４、将第三步的"),_("code",[v._v(".cpp")]),v._v("文件编译成动态链接库文件；")]),v._v(" "),_("p",[v._v("５、在"),_("code",[v._v("Java")]),v._v("中用"),_("code",[v._v("System.loadLibrary()")]),v._v("方法加载第四步产生的动态链接库文件，这个"),_("code",[v._v("native()")]),v._v("方法就可以在"),_("code",[v._v("Java")]),v._v("中被访问了。")]),v._v(" "),_("p",[_("code",[v._v("JAVA")]),v._v("本地方法适用的情况")]),v._v(" "),_("p",[v._v("1、为了使用底层的主机平台的某个特性，而这个特性不能通过"),_("code",[v._v("JAVA API")]),v._v("访问")]),v._v(" "),_("p",[v._v("2、为了访问一个老的系统或者使用一个已有的库，而这个系统或这个库不是用"),_("code",[v._v("JAVA")]),v._v("编写的")]),v._v(" "),_("p",[v._v("3、为了加快程序的性能，而将一段时间敏感的代码作为本地方法实现。")]),v._v(" "),_("h2",{attrs:{id:"new-新-创建"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#new-新-创建"}},[v._v("#")]),v._v(" new 新,创建")]),v._v(" "),_("p",[_("code",[v._v("new")]),v._v(" 关键字用于创建类的新实例。")]),v._v(" "),_("p",[_("code",[v._v("new")]),v._v(" 关键字后面的参数必须是类名，并且类名的后面必须是一组构造方法参数（必须带括号）。 参数集合必须与类的构造方法的签名匹配。")]),v._v(" "),_("p",[v._v("= 赋值号左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系。")]),v._v(" "),_("h2",{attrs:{id:"static-静态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#static-静态"}},[v._v("#")]),v._v(" static 静态")]),v._v(" "),_("p",[_("code",[v._v("static")]),v._v("可以用于修饰属性，可以修饰代码块，也可以用于修饰方法，还可以用于修饰类。")]),v._v(" "),_("p",[v._v("1、"),_("code",[v._v("static")]),v._v("修饰属性：无论一个类生成了多少个对象，所有这些对象共同使用唯一一份静态的成员变量；一个对象对该静态成员变量进行了修改，其他对象的该静态成员变量的值也会随之发生变化。如果一个成员变量是"),_("code",[v._v("static")]),v._v("的，那么我们可以通过‘"),_("code",[v._v("类名.成员变量名")]),v._v("’的方式来使用它。")]),v._v(" "),_("p",[v._v("2、"),_("code",[v._v("static")]),v._v("修饰方法："),_("code",[v._v("static")]),v._v("修饰的方法叫做静态方法。对于静态方法来说，可以使用‘类名.方法名’的方式来访问。静态方法只能继承，不能重写（"),_("code",[v._v("Override")]),v._v("），因为重写是用于表现多态的，重写只能适用于实例方法，而静态方法是可以不生成实例直接用类名来调用，这就会与重写的定义所冲突，与多态所冲突，所以静态方法不能重写，只能是隐藏。")]),v._v(" "),_("p",[_("code",[v._v("static")]),v._v("方法与非"),_("code",[v._v("static")]),v._v("方法：不能在静态方法中访问非静态成员变量；可以在静态方法中访问静态的成员变量。可以在非静态方法中访问静态的成员变量：因为静态方法可以直接用类名来调用，而非静态成员变量是在创建对象实例时才为变量分配内存和初始化变量值。")]),v._v(" "),_("p",[v._v("不能在静态方法中使用"),_("code",[v._v("this")]),v._v("关键字：因为静态方法可以直接用类名来调用，而"),_("code",[v._v("this")]),v._v("实际上是创建实例时，实例对应的一个应用，所以不能在静态方法上使用"),_("code",[v._v("this")]),v._v("。")]),v._v(" "),_("p",[v._v("3、"),_("code",[v._v("static")]),v._v("修饰代码块：静态代码块。静态代码块的作用也是完成一些初始化工作。首先执行静态代码块，然后执行构造方法。静态代码块在类被加载的时候执行，而构造方法是在生成对象的时候执行；要想调用某个类来生成对象，首先需要将类加载到Java虚拟机上（"),_("code",[v._v("JVM")]),v._v("），然后由"),_("code",[v._v("JVM")]),v._v("加载这个类来生成对象。")]),v._v(" "),_("p",[v._v("类的静态代码块只会执行一次，是在类被加载的时候执行的，因为每个类只会被加载一次，所以静态代码块也只会被执行一次；而构造方法则不然，每次生成一个对象的时候都会调用类的构造方法，所以"),_("code",[v._v("new")]),v._v("一次就会调用构造方法一次。如果继承体系中既有构造方法，又有静态代码块，那么首先执行最顶层的类的静态代码块，一直执行到最底层类的静态代码块，然后再去执行最顶层类的构造方法，一直执行到最底层类的构造方法。注意：静态代码块只会执行一次。")]),v._v(" "),_("p",[v._v("4、"),_("code",[v._v("static")]),v._v("修饰类：这个有点特殊，首先，"),_("code",[v._v("static")]),v._v("是可以用来修饰类的，但是"),_("code",[v._v("static")]),v._v("是不允许用来修饰普通类，只能用来修饰内部类，被"),_("code",[v._v("static")]),v._v("所修饰的内部类可以用"),_("code",[v._v("new")]),v._v("关键字来直接创建一个实例，不需要先创建外部类实例。"),_("code",[v._v("static")]),v._v("内部类可以被其他类实例化和引用（即使它是顶级类）。")]),v._v(" "),_("p",[v._v("其实理解起来也简单。因为"),_("code",[v._v("static")]),v._v("主要是修饰类里面的成员，包括内部类、属性、方法这些。修饰这些变量的目的也很单纯，那就是暗示这个成员在该类之中是唯一的一份拷贝，即便是不断的实例化该类，所有的这个类的对象都会共享这些"),_("code",[v._v("static")]),v._v("成员。这样就好办了。因为是共享的、唯一的，所以，也就不需要在实例化这个类以后再通过这个类来调用这个成员了，显然有点麻烦，所以就简单一点，直接通过类名直接调用"),_("code",[v._v("static")]),v._v("成员，更加直接。然而这样设置之后，就出现了一个限制，就是，"),_("code",[v._v("static")]),v._v("方法之中不能访问非"),_("code",[v._v("static")]),v._v("属性，因为这个时候非"),_("code",[v._v("static")]),v._v("属性可能还没有给他分配内存，该类还没有实例化。")]),v._v(" "),_("p",[v._v("所以，通常，"),_("code",[v._v("static")]),v._v(" 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。")]),v._v(" "),_("p",[v._v("可以从类的外部调用 "),_("code",[v._v("static")]),v._v(" 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。")]),v._v(" "),_("h2",{attrs:{id:"strictfp-严格-精准"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#strictfp-严格-精准"}},[v._v("#")]),v._v(" strictfp 严格,精准")]),v._v(" "),_("p",[_("code",[v._v("strictfp")]),v._v("的意思是"),_("code",[v._v("FP-strict")]),v._v("，也就是说精确浮点的意思。在"),_("code",[v._v("Java")]),v._v("虚拟机进行浮点运算时，如果没有指定"),_("code",[v._v("strictfp")]),v._v("关键字时，"),_("code",[v._v("Java")]),v._v("的编译器以及运行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令人满意。而一旦使用了"),_("code",[v._v("strictfp")]),v._v("来声明一个类、接口或者方法时，那么所声明的范围内"),_("code",[v._v("Java")]),v._v("的编译器以及运行环境会完全依照浮点规范IEEE-754来执行。因此如果想让浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，那就请用关键字"),_("code",[v._v("strictfp")]),v._v("。")]),v._v(" "),_("p",[v._v("可以将一个类、接口以及方法声明为"),_("code",[v._v("strictfp")]),v._v("，但是不允许对接口中的方法以及构造函数声明"),_("code",[v._v("strictfp")]),v._v("关键字。")]),v._v(" "),_("h2",{attrs:{id:"synchronized线程、同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#synchronized线程、同步"}},[v._v("#")]),v._v(" synchronized线程、同步")]),v._v(" "),_("p",[_("code",[v._v("synchronized")]),v._v(" 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。")]),v._v(" "),_("p",[_("code",[v._v("synchronized")]),v._v(" 关键字可防止代码的关键代码段一次被多个线程执行。")]),v._v(" "),_("p",[v._v("如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。")]),v._v(" "),_("p",[v._v("如果应用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。")]),v._v(" "),_("p",[v._v("如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。")]),v._v(" "),_("p",[v._v("一般的用法有：")]),v._v(" "),_("p",[v._v("1、"),_("code",[v._v("synchronized")]),v._v(" 方法控制对类成员变量的访问：每个类实例对应一把锁，")]),v._v(" "),_("p",[v._v("每个"),_("code",[v._v("synchronized")]),v._v(" 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 "),_("code",[v._v("synchronized")]),v._v(" 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 "),_("code",[v._v("synchronized")]),v._v("）。")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("Java")]),v._v("中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 "),_("code",[v._v("synchronized")]),v._v(" ，以控制其对类的静态成员变量的访问。")]),v._v(" "),_("p",[_("code",[v._v("synchronized")]),v._v(" 方法的缺陷：若将一个大的方法声明为"),_("code",[v._v("synchronized")]),v._v(" 将会大大影响效率，典型地，若将线程类的方法 "),_("code",[v._v("run()")]),v._v(" 声明为"),_("code",[v._v("synchronized")]),v._v(" ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何"),_("code",[v._v("synchronized")]),v._v(" 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 "),_("code",[v._v("synchronized")]),v._v(" ，并在主方法中调用来解决这一问题，但是 "),_("code",[v._v("Java")]),v._v(" 为我们提供了更好的解决办法，那就是 "),_("code",[v._v("synchronized")]),v._v("块。")]),v._v(" "),_("p",[v._v("2、synchronized块。")]),v._v(" "),_("p",[v._v("当两个并发线程访问同一个对象"),_("code",[v._v("object")]),v._v("中的这个"),_("code",[v._v("synchronized(this)")]),v._v("同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。")]),v._v(" "),_("p",[v._v("然而，当一个线程访问"),_("code",[v._v("object")]),v._v("的一个"),_("code",[v._v("synchronized(this)")]),v._v("同步代码块时，另一个线程仍然可以访问该"),_("code",[v._v("object")]),v._v("中的非"),_("code",[v._v("synchronized(this)")]),v._v("同步代码块。")]),v._v(" "),_("p",[v._v("尤其关键的是，当一个线程访问"),_("code",[v._v("object")]),v._v("的一个"),_("code",[v._v("synchronized(this)")]),v._v("同步代码块时，其他线程对"),_("code",[v._v("object")]),v._v("中所有其它"),_("code",[v._v("synchronized(this)")]),v._v("同步代码块的访问将被阻塞。同样适用其它同步代码块。也就是说，当一个线程访问"),_("code",[v._v("object")]),v._v("的一个"),_("code",[v._v("synchronized(this)")]),v._v("同步代码块时，它就获得了这个"),_("code",[v._v("object")]),v._v("的对象锁。结果，其它线程对该"),_("code",[v._v("object")]),v._v("对象所有同步代码部分的访问都被暂时阻塞。")]),v._v(" "),_("p",[v._v("这里的关键之处在于，这个"),_("code",[v._v("object")]),v._v("的对象锁只有一把，一把锁对应一个线程。")]),v._v(" "),_("h2",{attrs:{id:"transient-短暂"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#transient-短暂"}},[v._v("#")]),v._v(" transient 短暂")]),v._v(" "),_("p",[_("code",[v._v("transient")]),v._v(" 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。")]),v._v(" "),_("p",[v._v("当一个对象被串行化的时候，"),_("code",[v._v("transient")]),v._v("型变量的值不包括在串行化的表示中，然而非"),_("code",[v._v("transient")]),v._v("型的变量是被包括进去的。")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v("的"),_("code",[v._v("serialization")]),v._v("提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用"),_("code",[v._v("serialization")]),v._v("机制来保存它。为了在一个特定对象的一个域上关闭"),_("code",[v._v("serialization")]),v._v("，可以在这个域前加上关键字"),_("code",[v._v("transient")]),v._v("。")]),v._v(" "),_("p",[_("code",[v._v("transient")]),v._v("是"),_("code",[v._v("Java")]),v._v("语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，"),_("code",[v._v("transient")]),v._v("型变量的值不包括在串行化的表示中，然而非"),_("code",[v._v("transient")]),v._v("型的变量是被包括进去的。")]),v._v(" "),_("h2",{attrs:{id:"volatile-易失"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#volatile-易失"}},[v._v("#")]),v._v(" volatile 易失")]),v._v(" "),_("p",[_("code",[v._v("volatile")]),v._v(" 关键字用于表示可以被多个线程异步修改的成员变量。")]),v._v(" "),_("p",[v._v("注意："),_("code",[v._v("volatile")]),v._v(" 关键字在许多 "),_("code",[v._v("Java")]),v._v(" 虚拟机中都没有实现。 "),_("code",[v._v("volatile")]),v._v(" 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。")]),v._v(" "),_("p",[_("code",[v._v("Volatile")]),v._v("修饰的成员变量在每次被线程访问时，都强迫从主内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到主内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v("语言规范中指出：")]),v._v(" "),_("blockquote",[_("p",[v._v("为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。")])]),v._v(" "),_("p",[v._v("这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。")]),v._v(" "),_("p",[v._v("而"),_("code",[v._v("volatile")]),v._v("关键字就是提示"),_("code",[v._v("VM")]),v._v("：对于这个成员变量不能保存它的私有拷贝,而应直接与共享成员变量交互。")]),v._v(" "),_("p",[v._v("使用建议：在两个或者更多的线程访问的成员变量上使用"),_("code",[v._v("volatile")]),v._v("。当要访问的变量已在"),_("code",[v._v("synchronized")]),v._v("代码块中，或者为常量时，不必使用。")]),v._v(" "),_("p",[v._v("由于使用"),_("code",[v._v("volatile")]),v._v("屏蔽掉了"),_("code",[v._v("VM")]),v._v("中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 语言中的 "),_("code",[v._v("volatile")]),v._v(" 变量可以被看作是一种 “程度较轻的 "),_("code",[v._v("synchronized")]),v._v("”；与 "),_("code",[v._v("synchronized")]),v._v(" 块相比，"),_("code",[v._v("volatile")]),v._v(" 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 "),_("code",[v._v("synchronized")]),v._v(" 的一部分。")]),v._v(" "),_("h1",{attrs:{id:"程序控制语句"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程序控制语句"}},[v._v("#")]),v._v(" 程序控制语句")]),v._v(" "),_("h2",{attrs:{id:"break-跳出-中断"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#break-跳出-中断"}},[v._v("#")]),v._v(" break 跳出，中断")]),v._v(" "),_("p",[_("code",[v._v("break")]),v._v(" 关键字用于提前退出 "),_("code",[v._v("for、while 或 do 循环")]),v._v("，或者在 "),_("code",[v._v("switch")]),v._v(" 语句中用来结束 "),_("code",[v._v("case")]),v._v(" 块。")]),v._v(" "),_("p",[_("code",[v._v("break")]),v._v(" 总是退出最深层的 "),_("code",[v._v("while、for、do 或 switch 语句")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"continue-继续"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#continue-继续"}},[v._v("#")]),v._v(" continue 继续")]),v._v(" "),_("p",[_("code",[v._v("continue")]),v._v(" 关键字用来跳转到 "),_("code",[v._v("for、while 或 do 循环")]),v._v("的下一个迭代。")]),v._v(" "),_("p",[_("code",[v._v("continue")]),v._v(" 总是跳到最深层 "),_("code",[v._v("while、for 或 do 语句")]),v._v("的下一个迭代。")]),v._v(" "),_("h2",{attrs:{id:"return-返回"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#return-返回"}},[v._v("#")]),v._v(" return 返回")]),v._v(" "),_("p",[_("code",[v._v("return")]),v._v(" 关键字会导致方法返回到调用它的方法，从而传递与返回方法的返回类型匹配的值。 如果方法具有非 "),_("code",[v._v("void")]),v._v(" 的返回类型，"),_("code",[v._v("return")]),v._v(" 语句必须具有相同或兼容类型的参数。 返回值两侧的括号是可选的。")]),v._v(" "),_("h2",{attrs:{id:"do-运行"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#do-运行"}},[v._v("#")]),v._v(" do 运行")]),v._v(" "),_("p",[_("code",[v._v("do")]),v._v(" 关键字用于指定一个在每次迭代结束时检查其条件的循环。")]),v._v(" "),_("p",[_("code",[v._v("do")]),v._v(" 循环体至少执行一次。 条件表达式后面必须有分号。")]),v._v(" "),_("h2",{attrs:{id:"while-循环"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#while-循环"}},[v._v("#")]),v._v(" while 循环")]),v._v(" "),_("p",[_("code",[v._v("while")]),v._v(" 关键字用于指定一个只要条件为真就会重复的循环。")]),v._v(" "),_("h2",{attrs:{id:"if-如果"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#if-如果"}},[v._v("#")]),v._v(" if 如果")]),v._v(" "),_("p",[_("code",[v._v("if")]),v._v(" 关键字指示有条件地执行代码块。条件的计算结果必须是布尔值。")]),v._v(" "),_("p",[_("code",[v._v("if")]),v._v(" 语句可以有可选的 "),_("code",[v._v("else")]),v._v(" 子句，该子句包含条件为 "),_("code",[v._v("false")]),v._v(" 时将执行的代码。")]),v._v(" "),_("p",[v._v("包含 "),_("code",[v._v("boolean")]),v._v(" 操作数的表达式只能包含 "),_("code",[v._v("boolean")]),v._v(" 操作数。")]),v._v(" "),_("h2",{attrs:{id:"else-否则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#else-否则"}},[v._v("#")]),v._v(" else 否则")]),v._v(" "),_("p",[_("code",[v._v("else")]),v._v(" 关键字总是在 "),_("code",[v._v("if-else")]),v._v(" 语句中与 "),_("code",[v._v("if")]),v._v(" 关键字结合使用。"),_("code",[v._v("else")]),v._v(" 子句是可选的，如果 "),_("code",[v._v("if")]),v._v(" 条件为 "),_("code",[v._v("false")]),v._v("，则执行该子句。")]),v._v(" "),_("h2",{attrs:{id:"for-循环"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#for-循环"}},[v._v("#")]),v._v(" for 循环")]),v._v(" "),_("p",[_("code",[v._v("for")]),v._v(" 关键字用于指定一个在每次迭代结束前检查其条件的循环。")]),v._v(" "),_("p",[_("code",[v._v("for")]),v._v(" 语句的形式为 "),_("code",[v._v("for(initialize; condition; increment)")]),v._v(" 控件流进入 "),_("code",[v._v("for")]),v._v(" 语句时，将执行一次 "),_("code",[v._v("initialize")]),v._v(" 语句。 每次执行循环体之前将计算 "),_("code",[v._v("condition")]),v._v(" 的结果。如果 "),_("code",[v._v("condition")]),v._v(" 为 "),_("code",[v._v("true")]),v._v("，则执行循环体。")]),v._v(" "),_("p",[v._v("每次执行循环体之后，在计算下一个迭代的 "),_("code",[v._v("condition")]),v._v(" 之前，将执行 "),_("code",[v._v("increment")]),v._v(" 语句。")]),v._v(" "),_("h2",{attrs:{id:"instanceof-实例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#instanceof-实例"}},[v._v("#")]),v._v(" instanceof 实例")]),v._v(" "),_("p",[_("code",[v._v("instanceof")]),v._v(" 关键字用来确定对象所属的类。")]),v._v(" "),_("h2",{attrs:{id:"switch-观察"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#switch-观察"}},[v._v("#")]),v._v(" switch 观察")]),v._v(" "),_("p",[_("code",[v._v("switch")]),v._v(" 语句用于基于某个表达式选择执行多个代码块中的某一个。")]),v._v(" "),_("p",[_("code",[v._v("switch")]),v._v(" 条件的计算结果必须等于 "),_("code",[v._v("byte")]),v._v("、"),_("code",[v._v("char")]),v._v("、"),_("code",[v._v("short")]),v._v(" 或 "),_("code",[v._v("int")]),v._v("。")]),v._v(" "),_("p",[_("code",[v._v("case")]),v._v(" 块没有隐式结束点。"),_("code",[v._v("break")]),v._v(" 语句通常在每个 "),_("code",[v._v("case")]),v._v(" 块末尾使用，用于退出 "),_("code",[v._v("switch")]),v._v(" 语句。")]),v._v(" "),_("p",[v._v("如果没有 "),_("code",[v._v("break")]),v._v(" 语句，执行流将进入所有后面的 "),_("code",[v._v("case")]),v._v(" 和/或 "),_("code",[v._v("default")]),v._v(" 块。")]),v._v(" "),_("h2",{attrs:{id:"case-返回观察里的结果"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#case-返回观察里的结果"}},[v._v("#")]),v._v(" case 返回观察里的结果")]),v._v(" "),_("p",[_("code",[v._v("case")]),v._v(" 用来标记 "),_("code",[v._v("switch")]),v._v(" 语句中的每个分支。")]),v._v(" "),_("p",[_("code",[v._v("case")]),v._v(" 块没有隐式结束点。"),_("code",[v._v("break")]),v._v(" 语句通常在每个 "),_("code",[v._v("case")]),v._v(" 块末尾使用，用于退出 "),_("code",[v._v("switch")]),v._v(" 语句。")]),v._v(" "),_("p",[v._v("如果没有 "),_("code",[v._v("break")]),v._v(" 语句，执行流将进入所有后面的 "),_("code",[v._v("case")]),v._v(" 和/或 "),_("code",[v._v("default")]),v._v(" 块。")]),v._v(" "),_("h2",{attrs:{id:"default-默认"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#default-默认"}},[v._v("#")]),v._v(" default 默认")]),v._v(" "),_("p",[_("code",[v._v("default")]),v._v(" 关键字用来标记 "),_("code",[v._v("switch")]),v._v(" 语句中的默认分支。")]),v._v(" "),_("p",[_("code",[v._v("default")]),v._v(" 块没有隐式结束点。"),_("code",[v._v("break")]),v._v(" 语句通常在每个 "),_("code",[v._v("case")]),v._v(" 或 "),_("code",[v._v("default")]),v._v(" 块的末尾使用，以便在完成块时退出 "),_("code",[v._v("switch")]),v._v(" 语句。")]),v._v(" "),_("p",[v._v("如果没有 "),_("code",[v._v("default")]),v._v(" 语句，其参数与任何 "),_("code",[v._v("case")]),v._v(" 块都不匹配的 "),_("code",[v._v("switch")]),v._v(" 语句将不执行任何操作。")]),v._v(" "),_("h1",{attrs:{id:"错误处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[v._v("#")]),v._v(" 错误处理")]),v._v(" "),_("h2",{attrs:{id:"try-捕获异常"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#try-捕获异常"}},[v._v("#")]),v._v(" try 捕获异常")]),v._v(" "),_("p",[_("code",[v._v("try")]),v._v(" 关键字用于包含可能引发异常的语句块。")]),v._v(" "),_("p",[v._v("每个 "),_("code",[v._v("try")]),v._v(" 块都必须至少有一个 "),_("code",[v._v("catch")]),v._v(" 或 "),_("code",[v._v("finally")]),v._v(" 子句。")]),v._v(" "),_("p",[v._v("如果某个特定异常类未被任何 "),_("code",[v._v("catch")]),v._v(" 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 "),_("code",[v._v("try")]),v._v(" 块。如果任何封闭 "),_("code",[v._v("try")]),v._v(" 块都未捕获到异常，"),_("code",[v._v("Java")]),v._v(" 解释器将退出，并显示错误消息和堆栈跟踪信息。")]),v._v(" "),_("h2",{attrs:{id:"catch-处理异常"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#catch-处理异常"}},[v._v("#")]),v._v(" catch 处理异常")]),v._v(" "),_("p",[_("code",[v._v("catch")]),v._v(" 关键字用来在 "),_("code",[v._v("try-catch")]),v._v(" 或 "),_("code",[v._v("try-catch-finally")]),v._v(" 语句中定义异常处理块。")]),v._v(" "),_("p",[v._v("开始和结束标记 { 和 } 是 "),_("code",[v._v("catch")]),v._v(" 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。 每个 "),_("code",[v._v("try")]),v._v(" 块都必须至少有一个 "),_("code",[v._v("catch")]),v._v(" 或 "),_("code",[v._v("finally")]),v._v(" 子句。")]),v._v(" "),_("p",[v._v("如果某个特定异常类未被任何 "),_("code",[v._v("catch")]),v._v(" 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 "),_("code",[v._v("try")]),v._v(" 块。如果任何封闭 "),_("code",[v._v("try")]),v._v(" 块都未捕获到异常，"),_("code",[v._v("Java")]),v._v(" 解释器将退出，并显示错误消息和堆栈跟踪信息。")]),v._v(" "),_("h2",{attrs:{id:"throw-抛出一个异常对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#throw-抛出一个异常对象"}},[v._v("#")]),v._v(" throw 抛出一个异常对象")]),v._v(" "),_("p",[_("code",[v._v("throw")]),v._v(" 关键字用于引发异常。")]),v._v(" "),_("p",[_("code",[v._v("throw")]),v._v(" 语句将 "),_("code",[v._v("java.lang.Throwable")]),v._v(" 作为参数。"),_("code",[v._v("Throwable")]),v._v(" 在调用栈中向上传播，直到被适当的 "),_("code",[v._v("catch")]),v._v(" 块捕获。 引发非 "),_("code",[v._v("RuntimeException")]),v._v(" 异常的任何方法还必须在方法声明中使用 "),_("code",[v._v("throws")]),v._v(" 修饰符来声明它引发的异常。")]),v._v(" "),_("h2",{attrs:{id:"throws-声明一个异常可能被抛出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#throws-声明一个异常可能被抛出"}},[v._v("#")]),v._v(" throws 声明一个异常可能被抛出")]),v._v(" "),_("p",[_("code",[v._v("throws")]),v._v(" 关键字可以应用于方法，以便指出方法引发了特定类型的异常。")]),v._v(" "),_("p",[_("code",[v._v("throws")]),v._v(" 关键字将逗号分隔的 "),_("code",[v._v("java.lang.Throwables")]),v._v(" 列表作为参数。")]),v._v(" "),_("p",[v._v("引发非 "),_("code",[v._v("RuntimeException")]),v._v(" 异常的任何方法还必须在方法声明中使用 "),_("code",[v._v("throws")]),v._v(" 修饰符来声明它引发的异常。 要在 "),_("code",[v._v("try-catch")]),v._v(" 块中包含带 "),_("code",[v._v("throws")]),v._v(" 子句的方法的调用，必须提供该方法的调用者。")]),v._v(" "),_("h2",{attrs:{id:"finally"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#finally"}},[v._v("#")]),v._v(" finally")]),v._v(" "),_("p",[v._v("在异常处理机制当中，它的作用就像是人吃饭一样，必须得做的，不论有异常还是没有异常都要执行的代码就可以放到"),_("code",[v._v("finally")]),v._v("块当中去。"),_("code",[v._v("finally")]),v._v("块，必须要配合"),_("code",[v._v("try")]),v._v("块一起使用，不能单独使用，也不能直接和"),_("code",[v._v("catch")]),v._v("块一起使用。")]),v._v(" "),_("p",[_("code",[v._v("finally")]),v._v(" 关键字用来定义始终在 "),_("code",[v._v("try-catch-finally")]),v._v(" 语句中执行的块。")]),v._v(" "),_("p",[_("code",[v._v("finally")]),v._v(" 块通常包含清理代码，用在部分执行 "),_("code",[v._v("try")]),v._v(" 块后恢复正常运行。")]),v._v(" "),_("h1",{attrs:{id:"包相关"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#包相关"}},[v._v("#")]),v._v(" 包相关")]),v._v(" "),_("h2",{attrs:{id:"import-引入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#import-引入"}},[v._v("#")]),v._v(" import 引入")]),v._v(" "),_("p",[_("code",[v._v("import")]),v._v(" 关键字使一个包中的一个或所有类在当前 "),_("code",[v._v("Java")]),v._v(" 源文件中可见。可以不使用完全限定的类名来引用导入的类。")]),v._v(" "),_("p",[v._v("当多个包包含同名的类时，许多 "),_("code",[v._v("Java")]),v._v(" 程序员只使用特定的 "),_("code",[v._v("import")]),v._v(" 语句（没有“*”）来避免不确定性。")]),v._v(" "),_("h2",{attrs:{id:"package-包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#package-包"}},[v._v("#")]),v._v(" package 包")]),v._v(" "),_("p",[_("code",[v._v("package")]),v._v(" 关键字指定在 "),_("code",[v._v("Java")]),v._v(" 源文件中声明的类所驻留的 "),_("code",[v._v("Java")]),v._v(" 包。")]),v._v(" "),_("p",[_("code",[v._v("package")]),v._v(" 语句（如果出现）必须是 "),_("code",[v._v("Java")]),v._v(" 源文件中的第一个非注释性文本。 例:"),_("code",[v._v("java.lang.Object")]),v._v("。 如果 "),_("code",[v._v("Java")]),v._v(" 源文件不包含 "),_("code",[v._v("package")]),v._v(" 语句，在该文件中定义的类将位于“默认包”中。请注意，不能从非默认包中的类引用默认包中的类。")]),v._v(" "),_("h1",{attrs:{id:"基本类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本类型"}},[v._v("#")]),v._v(" 基本类型")]),v._v(" "),_("h2",{attrs:{id:"boolean-布尔型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#boolean-布尔型"}},[v._v("#")]),v._v(" boolean 布尔型")]),v._v(" "),_("p",[_("code",[v._v("boolean")]),v._v(" 是 "),_("code",[v._v("Java")]),v._v(" 原始类型。"),_("code",[v._v("boolean")]),v._v(" 变量的值可以是 "),_("code",[v._v("true")]),v._v(" 或 "),_("code",[v._v("false")]),v._v("。")]),v._v(" "),_("p",[_("code",[v._v("boolean")]),v._v(" 变量只能以 "),_("code",[v._v("true")]),v._v(" 或 "),_("code",[v._v("false")]),v._v(" 作为值。"),_("code",[v._v("boolean")]),v._v(" 不能与数字类型相互转换。")]),v._v(" "),_("p",[v._v("包含 "),_("code",[v._v("boolean")]),v._v(" 操作数的表达式只能包含 "),_("code",[v._v("boolean")]),v._v(" 操作数。")]),v._v(" "),_("p",[_("code",[v._v("Boolean")]),v._v(" 类是 "),_("code",[v._v("boolean")]),v._v(" 原始类型的包装对象类。")]),v._v(" "),_("h2",{attrs:{id:"byte-字节型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#byte-字节型"}},[v._v("#")]),v._v(" byte 字节型")]),v._v(" "),_("p",[_("code",[v._v("byte")]),v._v(" 是 "),_("code",[v._v("Java")]),v._v(" 原始类型。"),_("code",[v._v("byte")]),v._v(" 可存储在 "),_("code",[v._v("[-128, 127]")]),v._v(" 范围以内的整数值。")]),v._v(" "),_("p",[_("code",[v._v("Byte")]),v._v(" 类是 "),_("code",[v._v("byte")]),v._v(" 原始类型的包装对象类。它定义代表此类型的值的范围的 "),_("code",[v._v("MIN_VALUE")]),v._v(" 和 "),_("code",[v._v("MAX_VALUE")]),v._v(" 常量。 "),_("code",[v._v("Java")]),v._v(" 中的所有整数值都是 "),_("code",[v._v("32")]),v._v(" 位的 "),_("code",[v._v("int")]),v._v(" 值，除非值后面有 "),_("code",[v._v("l 或 L（如 235L）")]),v._v("，这表示该值应解释为 "),_("code",[v._v("long")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"char-字符型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#char-字符型"}},[v._v("#")]),v._v(" char 字符型")]),v._v(" "),_("p",[_("code",[v._v("char")]),v._v(" 是 "),_("code",[v._v("Java")]),v._v(" 原始类型。"),_("code",[v._v("char")]),v._v(" 变量可以存储一个 "),_("code",[v._v("Unicode")]),v._v(" 字符。")]),v._v(" "),_("p",[v._v("可以使用下列 "),_("code",[v._v("char")]),v._v(" 常量：")]),v._v(" "),_("p",[_("code",[v._v("\\b")]),v._v(" - 空格, "),_("code",[v._v("\\f")]),v._v(" - 换页, "),_("code",[v._v("\\n")]),v._v(" - 换行, "),_("code",[v._v("\\r")]),v._v(" - 回车, "),_("code",[v._v("\\t")]),v._v(" - 水平制表符, "),_("code",[v._v("'")]),v._v(" - 单引号, "),_("code",[v._v('"')]),v._v(" - 双引号, "),_("code",[v._v("\\")]),v._v(" - 反斜杠, "),_("code",[v._v("\\xxx")]),v._v(" - 采用 "),_("code",[v._v("xxx")]),v._v(" 编码的 "),_("code",[v._v("Latin-1")]),v._v(" 字符。"),_("code",[v._v("\\x")]),v._v(" 和 "),_("code",[v._v("\\xx")]),v._v(" 均为合法形式，但可能引起混淆。 "),_("code",[v._v("\\uxxxx")]),v._v(" - 采用十六进制编码 "),_("code",[v._v("xxxx")]),v._v(" 的 "),_("code",[v._v("Unicode")]),v._v(" 字符。")]),v._v(" "),_("p",[_("code",[v._v("Character")]),v._v(" 类包含一些可用来处理 "),_("code",[v._v("char")]),v._v(" 变量的 "),_("code",[v._v("static")]),v._v(" 方法，这些方法包括 "),_("code",[v._v("isDigit()")]),v._v("、"),_("code",[v._v("isLetter()")]),v._v("、"),_("code",[v._v("isWhitespace()")]),v._v(" 和 "),_("code",[v._v("toUpperCase()")]),v._v("。")]),v._v(" "),_("p",[_("code",[v._v("char")]),v._v(" 值没有符号。")]),v._v(" "),_("h2",{attrs:{id:"double-双精度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#double-双精度"}},[v._v("#")]),v._v(" double 双精度")]),v._v(" "),_("p",[_("code",[v._v("double")]),v._v(" 是 "),_("code",[v._v("Java")]),v._v(" 原始类型。d"),_("code",[v._v("o")]),v._v("uble 变量可以存储双精度浮点值。")]),v._v(" "),_("p",[v._v("由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 浮点数值可代表无穷大和 "),_("code",[v._v("NaN")]),v._v("（非数值）。"),_("code",[v._v("Double")]),v._v(" 包装对象类用来定义常量 "),_("code",[v._v("MIN_VALUE")]),v._v("、"),_("code",[v._v("MAX_VALUE")]),v._v("、"),_("code",[v._v("NEGATIVE_INFINITY")]),v._v("、"),_("code",[v._v("POSITIVE_INFINITY")]),v._v(" 和 "),_("code",[v._v("NaN")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"float-浮点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#float-浮点"}},[v._v("#")]),v._v(" float 浮点")]),v._v(" "),_("p",[_("code",[v._v("float")]),v._v(" 是 "),_("code",[v._v("Java")]),v._v(" 原始类型。"),_("code",[v._v("float")]),v._v(" 变量可以存储单精度浮点值。")]),v._v(" "),_("p",[v._v("使用此关键字时应遵循下列规则：")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 中的浮点文字始终默认为双精度。要指定单精度文字值，应在数值后加上 "),_("code",[v._v("f")]),v._v(" 或 "),_("code",[v._v("F")]),v._v("，如 "),_("code",[v._v("0.01f")]),v._v("。")]),v._v(" "),_("p",[v._v("由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 浮点数值可代表无穷大和 "),_("code",[v._v("NaN")]),v._v("（非数值）。"),_("code",[v._v("Float")]),v._v(" 包装对象类用来定义常量 "),_("code",[v._v("MIN_VALUE")]),v._v("、"),_("code",[v._v("MAX_VALUE")]),v._v("、"),_("code",[v._v("NEGATIVE_INFINITY")]),v._v("、"),_("code",[v._v("POSITIVE_INFINITY")]),v._v(" 和 "),_("code",[v._v("NaN")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"int-整型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#int-整型"}},[v._v("#")]),v._v(" int 整型")]),v._v(" "),_("p",[_("code",[v._v("int")]),v._v(" 是 "),_("code",[v._v("Java")]),v._v(" 原始类型。"),_("code",[v._v("int")]),v._v(" 变量可以存储 32 位的整数值。")]),v._v(" "),_("p",[_("code",[v._v("Integer")]),v._v(" 类是 int 原始类型的包装对象类。它定义代表此类型的值的范围的 "),_("code",[v._v("MIN_VALUE")]),v._v(" 和 "),_("code",[v._v("MAX_VALUE")]),v._v(" 常量。")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 中的所有整数值都是 32 位的 "),_("code",[v._v("int")]),v._v(" 值，除非值后面有 "),_("code",[v._v("l")]),v._v(" 或 L（如 "),_("code",[v._v("235L")]),v._v("），这表示该值应解释为 "),_("code",[v._v("long")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"long-长整型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#long-长整型"}},[v._v("#")]),v._v(" long 长整型")]),v._v(" "),_("p",[_("code",[v._v("long")]),v._v(" 是 "),_("code",[v._v("Java")]),v._v(" 原始类型。"),_("code",[v._v("long")]),v._v(" 变量可以存储 64 位的带符号整数。")]),v._v(" "),_("p",[_("code",[v._v("Long")]),v._v(" 类是 "),_("code",[v._v("long")]),v._v(" 原始类型的包装对象类。它定义代表此类型的值的范围的 "),_("code",[v._v("MIN_VALUE")]),v._v(" 和 "),_("code",[v._v("MAX_VALUE")]),v._v(" 常量。")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 中的所有整数值都是 32 位的 "),_("code",[v._v("int")]),v._v(" 值，除非值后面有 "),_("code",[v._v("l")]),v._v(" 或 L（如 "),_("code",[v._v("235L")]),v._v("），这表示该值应解释为 "),_("code",[v._v("long")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"short-短整型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#short-短整型"}},[v._v("#")]),v._v(" short 短整型")]),v._v(" "),_("p",[_("code",[v._v("short")]),v._v(" 是 Java 原始类型。"),_("code",[v._v("short")]),v._v(" 变量可以存储 16 位带符号的整数。")]),v._v(" "),_("p",[_("code",[v._v("Short")]),v._v(" 类是 "),_("code",[v._v("short")]),v._v(" 原始类型的包装对象类。它定义代表此类型的值的范围的 "),_("code",[v._v("MIN_VALUE")]),v._v(" 和 MAX_VALUE 常量。")]),v._v(" "),_("p",[_("code",[v._v("Java")]),v._v(" 中的所有整数值都是 32 位的 "),_("code",[v._v("int")]),v._v(" 值，除非值后面有 "),_("code",[v._v("l")]),v._v(" 或 L（如 "),_("code",[v._v("235L")]),v._v("），这表示该值应解释为 "),_("code",[v._v("long")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"null-空"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#null-空"}},[v._v("#")]),v._v(" null 空")]),v._v(" "),_("p",[_("code",[v._v("null")]),v._v(" 是 "),_("code",[v._v("Java")]),v._v(" 的保留字，表示无值。")]),v._v(" "),_("p",[v._v("将 null 赋给非原始变量相当于释放该变量先前所引用的对象。")]),v._v(" "),_("p",[v._v("不能将 "),_("code",[v._v("null")]),v._v(" 赋给原始类型（"),_("code",[v._v("byte、short、int、long、char、float、double、boolean")]),v._v("）变量。")]),v._v(" "),_("h2",{attrs:{id:"true-真"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#true-真"}},[v._v("#")]),v._v(" true 真")]),v._v(" "),_("p",[_("code",[v._v("true")]),v._v(" 关键字表示 "),_("code",[v._v("boolean")]),v._v(" 变量的两个合法值中的一个。")]),v._v(" "),_("h2",{attrs:{id:"false-假"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#false-假"}},[v._v("#")]),v._v(" false 假")]),v._v(" "),_("p",[_("code",[v._v("false")]),v._v(" 关键字代表 "),_("code",[v._v("boolean")]),v._v(" 变量的两个合法值之一。")]),v._v(" "),_("h1",{attrs:{id:"变量引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量引用"}},[v._v("#")]),v._v(" 变量引用")]),v._v(" "),_("h2",{attrs:{id:"super-父类-超类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#super-父类-超类"}},[v._v("#")]),v._v(" super 父类,超类")]),v._v(" "),_("p",[_("code",[v._v("super")]),v._v(" 关键字用于引用使用该关键字的类的超类。")]),v._v(" "),_("p",[v._v("作为独立语句出现的 "),_("code",[v._v("super")]),v._v(" 表示调用超类的构造方法。 "),_("code",[v._v("super.()")]),v._v(" 表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。")]),v._v(" "),_("h2",{attrs:{id:"this-本类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this-本类"}},[v._v("#")]),v._v(" this 本类")]),v._v(" "),_("p",[_("code",[v._v("this")]),v._v(" 关键字用于引用当前实例。 当引用可能不明确时，可以使用 "),_("code",[v._v("this")]),v._v(" 关键字来引用当前的实例。")]),v._v(" "),_("h2",{attrs:{id:"void-无返回值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#void-无返回值"}},[v._v("#")]),v._v(" void 无返回值")]),v._v(" "),_("p",[_("code",[v._v("void")]),v._v(" 关键字表示 "),_("code",[v._v("null")]),v._v(" 类型。 "),_("code",[v._v("void")]),v._v(" 可以用作方法的返回类型，以指示该方法不返回值。")]),v._v(" "),_("h1",{attrs:{id:"保留字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#保留字"}},[v._v("#")]),v._v(" 保留字")]),v._v(" "),_("p",[v._v("正确识别"),_("code",[v._v("java")]),v._v("语言的关键字（"),_("code",[v._v("keyword")]),v._v("）和保留字（"),_("code",[v._v("reserved word")]),v._v("）是十分重要的。"),_("code",[v._v("Java")]),v._v("的关键字对"),_("code",[v._v("java")]),v._v("的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等。保留字是为"),_("code",[v._v("java")]),v._v("预留的关键字，他们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 识别"),_("code",[v._v("java")]),v._v("语言的关键字，不要和其他语言如"),_("code",[v._v("c/c++")]),v._v("的关键字混淆。 "),_("code",[v._v("const")]),v._v("和"),_("code",[v._v("goto")]),v._v("是"),_("code",[v._v("java")]),v._v("的保留字。 所有的关键字都是小写")]),v._v(" "),_("h2",{attrs:{id:"goto-跳转"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#goto-跳转"}},[v._v("#")]),v._v(" goto 跳转")]),v._v(" "),_("p",[_("code",[v._v("goto")]),v._v(" 保留关键字，但无任何作用。结构化程序设计完全不需要 "),_("code",[v._v("goto")]),v._v(" 语句即可完成各种流程，而 "),_("code",[v._v("goto")]),v._v(" 语句的使用往往会使程序的可读性降低，所以 "),_("code",[v._v("Java")]),v._v(" 不允许 "),_("code",[v._v("goto")]),v._v(" 跳转。")]),v._v(" "),_("h2",{attrs:{id:"const-静态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#const-静态"}},[v._v("#")]),v._v(" const 静态")]),v._v(" "),_("p",[_("code",[v._v("const")]),v._v(" 保留字，是一个类型修饰符，使用"),_("code",[v._v("const")]),v._v("声明的对象不能更新。与final某些类似。")])])}),[],!1,null,null,null);_.default=t.exports}}]);