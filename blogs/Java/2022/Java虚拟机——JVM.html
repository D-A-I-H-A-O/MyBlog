<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java虚拟机——JVM | DAIHAO_小破站</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/MyBlog/favicon.ico">
    <meta name="description" content="一花一世界，一叶一菩提">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/MyBlog/assets/css/0.styles.9c73a019.css" as="style"><link rel="preload" href="/MyBlog/assets/js/app.9dfd65aa.js" as="script"><link rel="preload" href="/MyBlog/assets/js/3.76fec40c.js" as="script"><link rel="preload" href="/MyBlog/assets/js/1.0933c2a3.js" as="script"><link rel="preload" href="/MyBlog/assets/js/57.9b6b522b.js" as="script"><link rel="prefetch" href="/MyBlog/assets/js/10.7e335e14.js"><link rel="prefetch" href="/MyBlog/assets/js/11.2c226f08.js"><link rel="prefetch" href="/MyBlog/assets/js/12.f391e4e7.js"><link rel="prefetch" href="/MyBlog/assets/js/13.83e0c801.js"><link rel="prefetch" href="/MyBlog/assets/js/14.9dec8f13.js"><link rel="prefetch" href="/MyBlog/assets/js/15.0c93a32c.js"><link rel="prefetch" href="/MyBlog/assets/js/16.809cac13.js"><link rel="prefetch" href="/MyBlog/assets/js/17.180fb657.js"><link rel="prefetch" href="/MyBlog/assets/js/18.427c2138.js"><link rel="prefetch" href="/MyBlog/assets/js/19.3947f2e5.js"><link rel="prefetch" href="/MyBlog/assets/js/20.dc09376a.js"><link rel="prefetch" href="/MyBlog/assets/js/21.70e5f121.js"><link rel="prefetch" href="/MyBlog/assets/js/22.818293fa.js"><link rel="prefetch" href="/MyBlog/assets/js/23.d8307a2a.js"><link rel="prefetch" href="/MyBlog/assets/js/24.e586c895.js"><link rel="prefetch" href="/MyBlog/assets/js/25.7ba3d565.js"><link rel="prefetch" href="/MyBlog/assets/js/26.317ac9c6.js"><link rel="prefetch" href="/MyBlog/assets/js/27.971d85b5.js"><link rel="prefetch" href="/MyBlog/assets/js/28.b410d8b5.js"><link rel="prefetch" href="/MyBlog/assets/js/29.03bc1c8b.js"><link rel="prefetch" href="/MyBlog/assets/js/30.bd290479.js"><link rel="prefetch" href="/MyBlog/assets/js/31.664a5bab.js"><link rel="prefetch" href="/MyBlog/assets/js/32.6545d3ce.js"><link rel="prefetch" href="/MyBlog/assets/js/33.f6d59785.js"><link rel="prefetch" href="/MyBlog/assets/js/34.4f043f57.js"><link rel="prefetch" href="/MyBlog/assets/js/35.f258940b.js"><link rel="prefetch" href="/MyBlog/assets/js/36.b94e1d72.js"><link rel="prefetch" href="/MyBlog/assets/js/37.d3398d0a.js"><link rel="prefetch" href="/MyBlog/assets/js/38.07da415c.js"><link rel="prefetch" href="/MyBlog/assets/js/39.f7000e2d.js"><link rel="prefetch" href="/MyBlog/assets/js/4.1ae22871.js"><link rel="prefetch" href="/MyBlog/assets/js/40.184d9329.js"><link rel="prefetch" href="/MyBlog/assets/js/41.66a86df0.js"><link rel="prefetch" href="/MyBlog/assets/js/42.20ae4155.js"><link rel="prefetch" href="/MyBlog/assets/js/43.243d55ce.js"><link rel="prefetch" href="/MyBlog/assets/js/44.bcc3cad7.js"><link rel="prefetch" href="/MyBlog/assets/js/45.a80538a4.js"><link rel="prefetch" href="/MyBlog/assets/js/46.3b12b21d.js"><link rel="prefetch" href="/MyBlog/assets/js/47.7761cff9.js"><link rel="prefetch" href="/MyBlog/assets/js/48.958a1a67.js"><link rel="prefetch" href="/MyBlog/assets/js/49.f176aee9.js"><link rel="prefetch" href="/MyBlog/assets/js/5.9c753a0d.js"><link rel="prefetch" href="/MyBlog/assets/js/50.2988ca8a.js"><link rel="prefetch" href="/MyBlog/assets/js/51.59baebc3.js"><link rel="prefetch" href="/MyBlog/assets/js/52.23e7bd1a.js"><link rel="prefetch" href="/MyBlog/assets/js/53.a3a10635.js"><link rel="prefetch" href="/MyBlog/assets/js/54.e22d8f98.js"><link rel="prefetch" href="/MyBlog/assets/js/55.da49fb1b.js"><link rel="prefetch" href="/MyBlog/assets/js/56.d573388e.js"><link rel="prefetch" href="/MyBlog/assets/js/58.e6c5903d.js"><link rel="prefetch" href="/MyBlog/assets/js/59.234a5618.js"><link rel="prefetch" href="/MyBlog/assets/js/6.5f174aba.js"><link rel="prefetch" href="/MyBlog/assets/js/60.5aace1ea.js"><link rel="prefetch" href="/MyBlog/assets/js/61.863336cb.js"><link rel="prefetch" href="/MyBlog/assets/js/62.c2a79bd2.js"><link rel="prefetch" href="/MyBlog/assets/js/63.f5381aa1.js"><link rel="prefetch" href="/MyBlog/assets/js/64.8c1967d0.js"><link rel="prefetch" href="/MyBlog/assets/js/65.36466ee6.js"><link rel="prefetch" href="/MyBlog/assets/js/66.1c80c948.js"><link rel="prefetch" href="/MyBlog/assets/js/67.df668fb9.js"><link rel="prefetch" href="/MyBlog/assets/js/68.c6c4a754.js"><link rel="prefetch" href="/MyBlog/assets/js/69.65a0eff4.js"><link rel="prefetch" href="/MyBlog/assets/js/7.c6b6bcfd.js"><link rel="prefetch" href="/MyBlog/assets/js/70.b7f9ccf0.js"><link rel="prefetch" href="/MyBlog/assets/js/71.7538a7d5.js"><link rel="prefetch" href="/MyBlog/assets/js/72.642b5376.js"><link rel="prefetch" href="/MyBlog/assets/js/73.868b6f45.js"><link rel="prefetch" href="/MyBlog/assets/js/74.dae475f6.js"><link rel="prefetch" href="/MyBlog/assets/js/75.375b08dd.js"><link rel="prefetch" href="/MyBlog/assets/js/76.e200006d.js"><link rel="prefetch" href="/MyBlog/assets/js/77.cf2e1cf7.js"><link rel="prefetch" href="/MyBlog/assets/js/78.2bcd8ae9.js"><link rel="prefetch" href="/MyBlog/assets/js/79.967a40d9.js"><link rel="prefetch" href="/MyBlog/assets/js/8.8f27f8dd.js"><link rel="prefetch" href="/MyBlog/assets/js/80.5487c462.js"><link rel="prefetch" href="/MyBlog/assets/js/81.3e7b391d.js"><link rel="prefetch" href="/MyBlog/assets/js/82.00ff1192.js"><link rel="prefetch" href="/MyBlog/assets/js/83.e9de1625.js"><link rel="prefetch" href="/MyBlog/assets/js/84.5467ba10.js"><link rel="prefetch" href="/MyBlog/assets/js/85.205c04fc.js"><link rel="prefetch" href="/MyBlog/assets/js/9.4219d779.js">
    <link rel="stylesheet" href="/MyBlog/assets/css/0.styles.9c73a019.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-2d5f533b><div data-v-2d5f533b><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-2d5f533b data-v-2d5f533b><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-2d5f533b data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>DAIHAO_小破站</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>DAIHAO</span>
            
          <!---->
          2025
        </a></span></div></div> <div class="hide" data-v-2d5f533b><header class="navbar" data-v-2d5f533b><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/MyBlog/" class="home-link router-link-active"><img src="/MyBlog/logo.png" alt="DAIHAO_小破站" class="logo"> <span class="site-name">DAIHAO_小破站</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/MyBlog/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/MyBlog/categories/Database/" class="nav-link"><i class="iconfont undefined"></i>
  Database
</a></li><li class="dropdown-item"><!----> <a href="/MyBlog/categories/Java/" class="nav-link"><i class="iconfont undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/MyBlog/categories/Spring/" class="nav-link"><i class="iconfont undefined"></i>
  Spring
</a></li><li class="dropdown-item"><!----> <a href="/MyBlog/categories/SpringBoot/" class="nav-link"><i class="iconfont undefined"></i>
  SpringBoot
</a></li><li class="dropdown-item"><!----> <a href="/MyBlog/categories/Vue/" class="nav-link"><i class="iconfont undefined"></i>
  Vue
</a></li></ul></div></div><div class="nav-item"><a href="/MyBlog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/MyBlog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Docs
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/MyBlog/docs/DAIHAO/" class="nav-link"><i class="iconfont undefined"></i>
  DAIHAO
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/MyBlog/blogs/Java/2022/.html" class="nav-link"><i class="iconfont reco-github"></i>
  GitHub
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-2d5f533b></div> <aside class="sidebar" data-v-2d5f533b><div class="personal-info-wrapper" data-v-ca798c94 data-v-2d5f533b><img src="/MyBlog/avatar.png" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    DAIHAO
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>73</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>36</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/MyBlog/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/MyBlog/categories/Database/" class="nav-link"><i class="iconfont undefined"></i>
  Database
</a></li><li class="dropdown-item"><!----> <a href="/MyBlog/categories/Java/" class="nav-link"><i class="iconfont undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/MyBlog/categories/Spring/" class="nav-link"><i class="iconfont undefined"></i>
  Spring
</a></li><li class="dropdown-item"><!----> <a href="/MyBlog/categories/SpringBoot/" class="nav-link"><i class="iconfont undefined"></i>
  SpringBoot
</a></li><li class="dropdown-item"><!----> <a href="/MyBlog/categories/Vue/" class="nav-link"><i class="iconfont undefined"></i>
  Vue
</a></li></ul></div></div><div class="nav-item"><a href="/MyBlog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/MyBlog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Docs
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/MyBlog/docs/DAIHAO/" class="nav-link"><i class="iconfont undefined"></i>
  DAIHAO
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/MyBlog/blogs/Java/2022/.html" class="nav-link"><i class="iconfont reco-github"></i>
  GitHub
</a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Java虚拟机——JVM</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>DAIHAO</span>
            
          <!---->
          2025
        </a></span></div></div> <div data-v-2d5f533b><main class="page"><div class="page-title" style="display:none;"><h1 class="title">Java虚拟机——JVM</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>DAIHAO</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2022-02-21</span></i> <i class="iconfont reco-eye" data-v-3b7f5bdf><span id="/MyBlog/blogs/Java/2022/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94JVM.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-3b7f5bdf><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>JVM</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><p># 概述</p> <p><img src="https://img-blog.csdnimg.cn/20210703172421895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p><code>JVM</code>即所谓的<code>Java虚拟机</code>，是一个软件，用来执行一系列虚拟计算机指令，是二进制字节码的<code>运行环境</code>，负责装载字节码到其内部，解释（编译）为对应平台上的机器指令执行。</p> <p>其实，说<code>JVM</code>是<code>Java</code>的虚拟机已经不太准确，因为现在的<code>JVM</code>已经是一个跨语言的平台了，不仅是<code>Java</code>、<code>Kotlin</code>、<code>Clojure</code>，<code>Groovy</code>、<code>Scala</code>甚至<code>JavaScript</code>也可以通过特定的编译器进行编译生成字节码文件（字节码文件是编译后的二进制产物，不论是用什么语言进行编写的，只要能编译成对应的字节码文件，就能在<code>JVM</code>上运行）。因此，<code>JVM</code>就像是制定了一套自己的语言标准，其它任何语言都可以翻译到<code>JVM</code>，再由<code>JVM</code>和操作系统打交道，具体的针对不同平台的指令进行执行。</p> <h2 id="jdk、jre、jvm"><a href="#jdk、jre、jvm" class="header-anchor">#</a> JDK、JRE、JVM</h2> <ul><li><p><code>JDK（Java Development Kit）Java开发工具包</code>：是用来编译、调式<code>Java</code>程序的开发工具包。包括<code>Java</code>工具<code>（javac/java/jdb等）</code>和<code>Java</code>基础的类库<code>（Java API）</code></p></li> <li><p><code>JRE（Java Runtime Environment）Java运行时环境</code>: 是<code>Java平台</code>，所有的程序都要在<code>JRE</code>下才能运行。包括<code>JVM</code>和<code>Java</code>核心类库和支持文件。</p></li> <li><p><code>JVM（Java Virtual Machine）Java虚拟机</code>：是<code>JRE</code>的一部分。<code>JVM</code>主要工作是解释自己的指令集（即字节码）并映射到本地的<code>CPU</code>指令集和<code>OS</code>的系统调用。<code>Java</code>语言是跨平台运行的，不同的操作系统会有不用的<code>JVM</code>映射规则，使之与操作系统无关，完成跨平台性。</p></li></ul> <p>从大到小：JDK-&gt;JRE-&gt;JVM</p> <p>使用<code>JDK</code>（调用<code>Java API</code>）开发<code>Java</code>程序后，通过<code>JDK</code>中的编译程序<code>(javac)</code>将<code>Java</code>程序编译为<code>Java</code>字节码，在<code>JRE</code>上运行这些字节码，<code>JVM</code>会解析并映射到真实操作系统的<code>CPU</code>指令集和<code>OS</code>的系统调用。</p> <h2 id="jvm位置"><a href="#jvm位置" class="header-anchor">#</a> JVM位置</h2> <p><code>JVM</code>是运行在操作系统之上的，它与硬件没有直接的交互。</p> <p><img src="https://img-blog.csdnimg.cn/20210703172701984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <h2 id="jvm特点"><a href="#jvm特点" class="header-anchor">#</a> JVM特点</h2> <p>1、一次编译，到处运行</p> <p>2、自动内存管理</p> <p>2、自动垃圾回收机制</p> <h2 id="jvm结构"><a href="#jvm结构" class="header-anchor">#</a> JVM结构</h2> <p><code>Java虚拟机</code>在执行<code>Java</code>程序的过程中会把它所管理的内存划分为若干不同的数据区域。根据<code>Java虚拟机规范</code>的规定，<code>Java虚拟机</code>所管理的内存有以下几个区域：
<img src="https://img-blog.csdnimg.cn/20210703172607896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
在实际上，为了更好的适应<code>CPU</code>性能提升，最大限度提升<code>JVM</code>运行效率，<code>JDK</code>中各个版本对<code>JVM</code>进行了一些迭代：
<img src="https://img-blog.csdnimg.cn/20210707135500757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p><code>JDK1.6</code>、<code>JDK1.7</code>、<code>JDK1.8</code>主要有以下差异：</p> <ul><li><code>JDK1.6</code>：有永久代，静态变量存放在永久代上。</li> <li><code>JDK1.7</code>：有永久代，但已经把字符串常量池、静态变量、存放在堆上。逐渐减少永久代的使用。</li> <li><code>JDK1.8</code>：去除永久代。运行时常量池、类常量池都保存在元数据区，也就是常说的<code>元空间</code>。但是字符串常量池依然存放在堆上。</li></ul> <h3 id="class常量池、运行时常量池、字符串常量池"><a href="#class常量池、运行时常量池、字符串常量池" class="header-anchor">#</a> Class常量池、运行时常量池、字符串常量池</h3> <blockquote><p>为什么需要常量池</p></blockquote> <p>一个<code>Java</code>源文件中的类、接口，编译后会产生一个字节码文件，而<code>Java</code>中的字节码文件需要其他的数据支撑，通常这种数据很大，不能直接存放到字节码里面。所以把对这些数据的引用存放到常量池，在真正需要的时候，通过动态链接将符号引用转为直接引用。</p> <blockquote><p>符号引用和直接引用</p></blockquote> <p>1、符号引用：符号引用是一组符号来描述是引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标就行。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定加载到了内存中。</p> <p>2、直接引用：直接引用可以是指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接目标与虚拟机内存布局相关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在与内存之中了。
<img src="https://img-blog.csdnimg.cn/20210713221720356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <code>Constant Pool</code>也就是常量池中有22项内容，其中带<code>Utf8</code>的就是符号引用。比如<code>#2</code>，它的值是<code>com/xrq/test6/TestMain</code>，表示的是这个类的全限定名；又比如<code>#5</code>为<code>i</code>，<code>#6</code>为<code>I</code>，它们是一对的，表示变量是<code>Integer（int）</code>类型的，名字叫做<code>i</code>；<code>#6</code>为<code>D</code>、<code>#7</code>为<code>d</code>也是一样，表示一个<code>Double（double）</code>类型的变量，名字为<code>d</code>；<code>#18</code>、<code>#19</code>表示的都是方法的名字。</p> <ul><li>Class常量池</li></ul> <p>当<code>Java</code>类被编译后形成<code>class</code>文件，<code>class</code>文件中除了包含类的版本、字段、方法、接口等描述信息外。还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用。
<img src="https://img-blog.csdnimg.cn/20210714160929458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p><img src="https://img-blog.csdnimg.cn/20210714150642804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <ul><li>运行时常量池</li></ul> <p>常量池指的是字节码中的<code>Constant pool</code>部分，当字节码文件被加载到内存中后，方法区中会存放字节码文件的<code>Constant pool</code>相关信息，这时候也就成为了运行时常量池。运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，而是真实地址。</p> <p>另外，运行时常量池具有动态性。也就是在方法区中的运行时常量池是可以发生变化的。而常量池不是，它是静态的，当编译生成字节码文件后就不变了。</p> <ul><li>字符串常量池</li></ul> <p>全局字符串常量池（也就是字符串常量池 <code>string pool</code>也有叫做<code>string literal pool</code>）里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到字符串常量池中。（字符串常量池中存的是引用值，而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）在<code>HotSpot VM</code>里实现的字符串常量池功能是一个<code>StringTable</code>类，它是一个哈希表，里面存的是驻留字符串（也就是常说的用双引号括起来的）的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个<code>StringTable</code>引用之后就等同被赋予了“驻留字符串”的身份。这个<code>StringTable</code>在每个<code>HotSpot VM</code>的实例只有一份，被所有的类共享。
<img src="https://img-blog.csdnimg.cn/20210714163820170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <h2 id="class-file"><a href="#class-file" class="header-anchor">#</a> Class File</h2> <p><a href="https://www.cnblogs.com/zsql/p/12907120.html" target="_blank" rel="noopener noreferrer">java class文件详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="类加载机制"><a href="#类加载机制" class="header-anchor">#</a> 类加载机制</h2> <p><code>Java虚拟机</code>把描述类的数据从<code>Class</code>文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的<code>Java</code>类的原型（类模板对象），这就是虚拟机的类加载机制。</p> <blockquote><p>所谓类模板对象，其实就是<code>Java</code>类在<code>JVM</code>内存中的一个快照，<code>JVM</code>将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中。这样<code>JVM</code>在运行期便能通过类模板而获取<code>Java</code>类中的任意信息。能够对<code>Java</code>类的成员变量进行遍历，也能进行<code>Java</code>方法的调用。</p></blockquote> <h3 id="类的生命周期"><a href="#类的生命周期" class="header-anchor">#</a> 类的生命周期</h3> <p><img src="https://img-blog.csdnimg.cn/20210714073817321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <h4 id="类的加载"><a href="#类的加载" class="header-anchor">#</a> 类的加载</h4> <p>类的加载指的就是将类的<code>class</code>文件中的二进制数据读取到内存中，存放在运行时数据区的方法区中，并在堆中创建一个大的<code>java.lang.Class</code>对象，用来封装方法区内的数据结构。</p> <p><img src="https://img-blog.csdnimg.cn/20210712074659537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <blockquote><p>加载时虚拟机做了什么</p></blockquote> <ul><li>通过类的全名，获取类的二进制数据流</li> <li>解析类的二进制数据流为方法区内的数据结构（<code>Java</code>类模型）</li> <li>创建<code>java.lang.Class</code>类的实例,表示该类型。作为方法区这个类的各种数据的访问入口。（一般这个<code>class</code>对象会存储在堆中，不过<code>HotSpot</code>虚拟机比较特殊，这个<code>class</code>对象是放在方法区中的。）</li></ul> <blockquote><p>何时加载</p></blockquote> <ul><li>预加载：在虚拟机启动的时候会加载，加载的时<code>JAVA_HOME/lib</code>下的<code>rt.class</code>下的<code>.class</code>文件，是<code>java</code>程序运行时需要的类。比如<code>java.lang.*</code>以及<code>java,util.*</code>等</li> <li>运行时加载：虚拟机中在用到一个<code>.class</code>文件时，首先会去内存找你查找这个<code>.class</code>文件有没有被加载，没有被加载会根据这个类的全限定名去加载。</li></ul> <blockquote><p>怎么获取类的二进制流</p></blockquote> <ul><li>通过文件系统读入一个<code>class</code>后缀的文件</li> <li>从<code>zip</code>包中获取，这就是以后<code>jar</code>、<code>ear</code>、<code>war</code>格式的基础</li> <li>从网络中获取，典型应用就是<code>Applet</code></li> <li>运行时计算生成，典型应用就是动态代理技术</li> <li>由其他文件生成，典型应用就是<code>JSP</code>，即由<code>JSP</code>生成对应的<code>.class</code>文件</li> <li>从数据库中读取，这种场景比较少见</li></ul> <p>其实无论是通过<code>ZIP</code>，还是通过网络，还是通过其他文件生成，最终都是通过一个类的全限定名来获取类的二进制字节流。 通过一个类的全限定名来获取类的二进制字节流是目的，<code>ZIP</code>，网络，文件是手段。</p> <h4 id="类的验证"><a href="#类的验证" class="header-anchor">#</a> 类的验证</h4> <p>即验证<code>Class</code>文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p> <blockquote><p>四种验证</p></blockquote> <ul><li><p>文件格式验证：验证字节流是否符合<code>Class</code>文件规范，符合规范通过验证才能保证输入的字节流能正确的被解析并存储到方法区。</p></li> <li><p>元数据验证：对类的元数据信息进行语义校验</p></li> <li><p>字节码验证：检验程序语义是否符合规范，符合逻辑，对类的方法进行校验</p></li> <li><p>符号引用验证：发生在将符号引用转换为直接引用的时候，可以看作是对类自身以外（常量池中各种符号的应用）信息的匹配校验。如：符号引用中通过字符串描述的全限定名是否能找到对应的类；符号引用中的类、字段、方法的访问性（<code>private、protected、public、default</code>）是否可被当前类访问</p></li></ul> <p><img src="https://img-blog.csdnimg.cn/2021071321551948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <h4 id="类的准备"><a href="#类的准备" class="header-anchor">#</a> 类的准备</h4> <p>准备：为类变量分配内存并默认初始化值。</p> <p>注意：</p> <ul><li>只为类变量，即被<code>static</code>修饰的变量分配内存，实例变量在实例初始化的时候会随对象一起分配在堆中。</li> <li>这个阶段初始化赋值的变量不包括<code>final</code>修饰的<code>static</code>变量，因为<code>final</code>在编译的时候就会分配了,准备阶段会显式赋值。</li> <li><code>Java</code>并不支持<code>boolean</code>类型，对于<code>boolean</code>类型，内部实现是<code>int</code>,由于<code>int</code>的默认值是0,故对应的，<code>boolean</code>的默认值就是<code>false</code> <img src="https://img-blog.csdnimg.cn/2021071322090133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul> <h4 id="类的解析"><a href="#类的解析" class="header-anchor">#</a> 类的解析</h4> <p>解析：将常量池中的符号引用转为直接引用的过程。（将类、接口、字段和方法的符号引用转为直接引用）。</p> <p>虚拟机在加载<code>Class</code>文件时才会动态链接，也就是说，<code>Class</code>文件中不会保存各个方法和字段的最终内存布局信息。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行，要从常量池中获得对应的符号引用，再在类加载过程中（初始化阶段）将其替换成直接引用。</p> <p><code>Java</code>虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在<code>HotSpot VM</code>中,加载、验证、准备和初始化会按照顺序有条不紊地执行,但链接阶段中的解析操作往往会伴随着<code>JVM</code>在执行完初始化之后再执行</p> <h4 id="类的初始化"><a href="#类的初始化" class="header-anchor">#</a> 类的初始化</h4> <p>开始真正执行类中定义的<code>Java</code>代码，初始化过程就是执行类构造器<code>&lt;clint&gt;()</code>的过程。之前的准备阶段是给类变量分配内存赋初始值，初始化是将类变量赋予用户指定的值。</p> <p>此方法不需要定义，是<code>javac</code>编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</p> <p>若类有父类，<code>JVM</code>会保证在子类的<code>&lt;clint&gt;()</code>执行前，先完成父类的<code>&lt;clint&gt;()</code>。<code>&lt;clint&gt;()</code>不同与类的构造方法<code>init</code>(由父及子，静态先行)</p> <p><code>Java</code>编译器不会为所有的类都产生<code>&lt;clint&gt;()</code>初始化方法。有些类在编译为字节码后，字节码文件中不会包含<code>&lt;clint&gt;()</code>方法。</p> <ul><li>一个类中没有声明任何变量，也没有静态代码块时</li> <li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</li> <li>一个类中包含<code>static，final</code>修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式（如果这个<code>static，final</code>不是通过方法或者构造器，则在链接阶段。）</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 哪些场景下，java编译器就不会生成&lt;clinit&gt;()方法
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitializationTest</span> <span class="token punctuation">{</span>
    <span class="token comment">//对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">//静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> num1<span class="token punctuation">;</span>
    <span class="token comment">//比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">/**
 * 说明：使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？
 * 情况1：在链接阶段的准备环节赋值
 * 情况2：在初始化阶段&lt;clinit&gt;()中赋值
 * 结论：
 * 在链接阶段的准备环节赋值的情况：
 * 1. 对于基本数据类型的字段来说，如果使用static final修饰，
 * 则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行
 * 
 * 2. 对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，
 * 则显式赋值通常是在链接阶段的准备环节进行
 *
 * 在初始化阶段&lt;clinit&gt;()中赋值的情况：
 * 排除上述的在准备环节赋值的情况之外的情况。
 * 最终结论：使用static + final修饰，
 * 且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，
 * 是在链接阶段的准备环节进行。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitializationTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">INT_CONSTANT</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//在链接阶段的准备环节赋值</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> <span class="token constant">INTEGER_CONSTANT1</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token constant">INTEGER_CONSTANT2</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> s0 <span class="token operator">=</span> <span class="token string">&quot;helloworld0&quot;</span><span class="token punctuation">;</span><span class="token comment">//在链接阶段的准备环节赋值</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;helloworld1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">&quot;helloworld2&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">NUM1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在初始化阶段&lt;clinit&gt;()中赋值</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p><strong>触发初始化</strong></p> <p>如果一个类被直接引用，就会触发类的初始化。在<code>java</code>中，直接引用的情况有：</p> <ul><li><p>通过<code>new</code>关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。</p></li> <li><p>通过反射方式执行以上三种行为。</p></li> <li><p>初始化子类的时候，会触发父类的初始化。</p></li> <li><p>作为程序入口直接运行时（也就是直接调用<code>main</code>方法）。</p></li> <li><p><code>JDK1.7</code>开始提供的动态语言支持，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic、REF_putStatic、REF_invokeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</p></li></ul> <p>除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。意味着没有<code>&lt;clint&gt;()</code>的调用</p> <ul><li><p>调用<code>ClassLoader</code>类的<code>loadClass()</code>方法加载一个类，并不是对类的主动使用，不会导致类的初始化</p></li> <li><p>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。当通过子类引用父类的静态变量，不会导致子类初始化</p></li> <li><p>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了</p></li> <li><p>通过数组定义类引用，不会触发此类的初始化</p></li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code># 这里不会进行初始化<span class="token punctuation">,</span>因为相当于parent只开辟了空间<span class="token punctuation">,</span>没赋值
<span class="token class-name">Parent</span><span class="token punctuation">[</span><span class="token punctuation">]</span>parent<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="类的使用"><a href="#类的使用" class="header-anchor">#</a> 类的使用</h4> <p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便&quot;万事俱备,只欠东风&quot;就等着开发者使用了</p> <p>开发人员可以在程序中访问和调用它的静态类成员信息(比如：静态字段、静态方法)或者使用<code>new</code>关键字为其创建对象实例</p> <h4 id="类的卸载"><a href="#类的卸载" class="header-anchor">#</a> 类的卸载</h4> <p>卸载类即该类的<code>Class</code> 对象被 <code>GC</code>。</p> <p>卸载类需要满足 3 个要求:</p> <ul><li>该类的所有的实例对象都已被 <code>GC</code>，也就是说堆不存在该类的实例对象。</li> <li>该类没有在其他任何地方被引用</li> <li>该类的类加载器的实例已被 <code>GC</code></li></ul> <p>所以，在 <code>JVM</code> 生命周期内，由 <code>jvm</code> 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p> <p><code>jdk</code> 自带的 <code>BootstrapClassLoader, ExtClassLoader, AppClassLoader</code> 负责加载 <code>jdk</code> 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p> <h2 id="类加载器"><a href="#类加载器" class="header-anchor">#</a> 类加载器</h2> <p>类加载器<code>ClassLoader</code>，是 <code>Java</code> 的核心组件，只负责加载<code>class</code>文件，<code>class</code>文件在文件开头有特定的文件标示，将<code>class</code>文件字节码内容加载到内存中。<code>ClassLoader</code>只负责<code>class</code>文件的加载，至于它是否可以运行，则由执行引擎<code>Execution Engine</code>决定。</p> <blockquote><p>JVM自带的加载器</p></blockquote> <ul><li><p>启动类加载器：<code>BootstrapClassLoader</code> 主要加载的是JVM自身需要的类，这个类加载使用<code>C++</code>语言实现的，是虚拟机自身的一部分，它负责将 <code>&lt;JAVA_HOME&gt;/lib</code>路径下的核心类库或<code>-Xbootclasspath</code>参数指定的路径下的<code>jar包</code>加载到内存中，注意由于虚拟机是按照文件名识别加载<code>jar包</code>的，如<code>rt.jar</code>，如果文件名不被虚拟机识别，即使把<code>jar包</code>丢到<code>lib</code>目录下也是没有作用的(出于安全考虑，<code>Bootstrap</code>启动类加载器只加载包名为<code>java、javax、sun</code>等开头的类)。</p></li> <li><p>扩展类加载器：<code>ExtensionClassLoader</code> 扩展类加载器是<code>sun.misc.Launcher$ExtClassLoader</code>类，由<code>Java</code>语言实现的，是<code>Launcher</code>的静态内部类，它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录下或者由系统变量<code>-Djava.ext.dir</code>指定位路径中的类库，开发者可以直接使用标准扩展类加载器。</p></li> <li><p>系统类加载器：<code>AppClassLoader</code>也叫应用类程序加载器，也是由<code>Java</code>实现的。它从环境变量<code>classpath</code>或者系统属性<code>java.class.path</code>所指定的目录中加载类，它是用户自定义的类加载器的默认父加载器。</p></li></ul> <blockquote><p>用户自定义加载器</p></blockquote> <ul><li><code>java.lang.ClassLoader</code>的子类，用户可以定制类的加载方式。</li></ul> <h3 id="双亲委派机制"><a href="#双亲委派机制" class="header-anchor">#</a> 双亲委派机制</h3> <p>当<code>JVM</code>加载一个类的时候，下层的加载器会将任务给上一层类加载器，上一层加载检查它的命名空间中是否已经加载这个类，如果已经加载，则直接使用这个类。如果没有加载，继续往上委托直到顶部。检查之后，按照相反的顺序进行加载。如果<code>Bootstrap</code>加载不到这个类，则往下委托，直到找到这个类，如果都不能加载则<code>ClassNotFoundException</code> 。一个类可以被不同的类加载器加载。
<img src="https://img-blog.csdnimg.cn/20210706145538210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p>可见性限制：下层的加载器能够看到上层加载器中的类，反之则不行，委派只能从下到上。</p> <p>不允许卸载类：类加载可以加载一个类，但不能够卸载一个类。但是类加载器可以被创建或者删除。</p> <p><strong>ClassLoader源码（双亲委派机制模型）</strong>
（往上看有没有被加载过，有就使用，则确保唯一性和安全性，如果都没有则往下尝试加载，也是有就使用，如果都不能加载则<code>ClassNotFoundException</code> ）</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 首先检查这个classsh是否已经加载过了</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// c==null表示没有加载，如果有父类的加载器则让父类加载器加载</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                        <span class="token comment">//如果父类的加载器为空 则说明递归到bootStrapClassloader了</span>
                        <span class="token comment">//bootStrapClassloader比较特殊无法通过get获取</span>
                        c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">//如果bootstrapClassLoader 仍然没有加载过，则递归回来，尝试自己去加载class</span>
                    <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> c<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p><strong>委托机制的意义</strong></p> <ul><li>防止内存中出现多份同样的字节码。
比如两个类A和类B都要加载<code>System</code>类，如果不用委托而是自己加载自己的，那么类A就会加载一份<code>System</code>字节码，然后类B又会加载一份<code>System</code>字节码，这样内存中就出现了两份<code>System</code>字节码。如果使用委托机制，会递归的向父类查找，也就是首选用<code>Bootstrap</code>尝试加载，如果找不到再向下。这里的<code>System</code>就能在<code>Bootstrap</code>中找到然后加载，如果此时类B也要加载<code>System</code>，也从<code>Bootstrap</code>开始，此时<code>Bootstrap</code>发现已经加载过了<code>System</code>那么直接返回内存中的<code>System</code>即可而不需要重新加载，这样内存中就只有一份<code>System</code>的字节码了。</li> <li>安全性
黑客自定义一个<code>java.lang.String</code>类，该<code>String</code>类具有系统的<code>String</code>类一样的功能，只是在某个函数稍作修改。比如<code>equals</code>函数，这个函数经常使用，如果在这这个函数中，黑客加入一些“病毒代码”。并且通过自定义类加载器加入到<code>JVM</code>中。此时，如果没有双亲委派模型，那么<code>JVM</code>就可能误以为黑客自定义的<code>java.lang.String</code>类是系统的<code>String</code>类，导致“病毒代码”被执行。而有了双亲委派模型，黑客自定义的<code>java.lang.String</code>类永远都不会被加载进内存。因为首先是最顶端的类加载器加载系统的<code>java.lang.String</code>类，最终自定义的类加载器无法加载<code>java.lang.String</code>类。
或许你会想，我在自定义的类加载器里面强制加载自定义的<code>java.lang.String</code>类，不去通过调用父加载器不就好了吗?确实，这样是可行。但是，在<code>JVM</code>中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回<code>false</code>。</li></ul> <p><a href="http://www.blogjava.net/zhuxing/archive/2008/08/08/220841.html" target="_blank" rel="noopener noreferrer">Java类加载原理解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6844903633574690824" target="_blank" rel="noopener noreferrer">JVM 类加载机制及双亲委派模型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="运行时数据区"><a href="#运行时数据区" class="header-anchor">#</a> 运行时数据区</h2> <h3 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h3> <p>对于大多数应用来说，<code>Java堆</code>是<code>Java</code>虚拟机所管理的内存最大的一块，<code>Java堆</code>是被所有线程共享的区域，在虚拟机启动时创建。此内存区域唯一的目的性就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p> <p><code>Java堆</code>是垃圾收集器管理的主要区域，因此被称为<code>GC堆</code>。如果从内存回收的角度看，由于现在的收集器基本上都是采用的分代收集算法，所以<code>Java堆</code>还可以细分为：新生代和老年代，在细致一点有<code>Eden空间</code>、<code>From Survivor 空间</code>、<code>To Survivor空间</code>等。</p> <p>根据<code>Java虚拟机</code>规范，<code>Java堆</code>可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像磁盘空间一样，实现时既可以实现成固定大小，也可以时可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过<code>-Xmx</code>和<code>-Xms</code>控制）。
<img src="https://img-blog.csdnimg.cn/20210710104559178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p>堆大小=新生代+老年代。堆的大小可以通过参数<code>-Xms</code>、<code>-Xmx</code>来指定.</p> <p>新生代与老年代默认的比值为1:2,（该值可以通过参数 <code>-XX:NewRatio</code>来指定，默认<code>-XX:NewRatio=2</code>年轻代占整个堆的1/3，老年代占堆的2/3；假如<code>-XX:NewRatio=4</code>新生代占1,老年代占4,年轻代占整个堆的1/5，<code>NewRatio</code>就是设置老年代的占比,剩下的1给新生代）。</p> <p>默认情况下，<code>Edem:from:to=8:1:1</code>，可以通过参数<code>-XX:SurvivorRatio</code>来设置<code>Eden</code>区与每一个<code>Survivor</code>区的比值.</p> <p><code>JVM</code> 每次只会使⽤<code>Eden</code> 和其中的⼀块 <code>Survivor</code>区域来为对象服务，所以⽆论什么时候，总是有⼀块 <code>Survivor</code>区域是空闲着的。因此，新⽣代实际可⽤的内存空间为 9/10 ( 即90% )的新⽣代空间。</p> <h3 id="方法区"><a href="#方法区" class="header-anchor">#</a> 方法区</h3> <p>方法区和<code>Java堆</code>一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的<code>类信息、常量、静态变量、即时编译器编译后的代码</code>等数据。虽然<code>Java虚拟机</code>规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做<code>Non-Heap(非堆)</code>，目的应该就是与<code>Java堆</code>区分开来。</p> <p>在<code>JDK1.8</code>以前，<code>HotSpot</code>使用永久代来实现方法区，所以某些场合也认为方法区和永久代是一个概念。</p> <p>在<code>JDK 1.6</code>的 时候<code>HotSpot</code>开发团队就有放弃永久代，逐步改为采用本地内存（<code>Native Memory</code>）来实现方法区的计划了，到了<code>JDK 1.7</code>的<code>HotSpot</code>，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 <code>JDK 1.8</code>，终于完全废弃了永久代的概念，改用在本地内存中实现的元空间（<code>Meta- space</code>）来代替，把<code>JDK 1.7</code>中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</p> <p>元空间的本质和永久代类似，都是对 <code>JVM</code>规范中方法区的实现。元空间与永久代最大的区别在于：永久代使用的是堆内存，但是<code>Java8</code>以后的元空间并不在虚拟机中而是使用本机物理内存。</p> <p><code>Java虚拟机</code>规范对方法区的限制非常宽松，除了和<code>Java堆</code>一样不需要连续的内存和可以选择固定大小或者可以扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是对类型的卸载，条件相当苛刻，但这个区域的回收确实是有必要的.</p> <p>根据<code>Java虚拟机</code>规范，当方法区无法满足内存分配需求是，将抛出<code>OutOfMemoryError</code>异常。</p> <h3 id="程序计数器"><a href="#程序计数器" class="header-anchor">#</a> 程序计数器</h3> <p><code>Program Counter Register</code>是一块比较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，不用虚拟机不同方法实现），字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p> <p>由于<code>Java虚拟机</code>的多线程是通过线程轮流切换并分配处理器执行时间来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间的计数器互不影响，独立存储，称这类内存区域为<code>线程私有</code>的内存。</p> <p>如果线程正在执行的是一个<code>Java</code>方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是<code>Natvie</code>方法，这个计数器值则为空<code>（Undefined）</code>。</p> <p>此内存空间是唯一一个在<code>Java虚拟机</code>规范中没有规定<code>OutOfMemoryError</code>情况的区域。</p> <h3 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h3> <p>与程序计数器一样，<code>Java虚拟机栈</code>也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是<code>Java</code>方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧用于存储<code>局部变量表</code>、<code>操作栈</code>、<code>动态链接</code>、<code>方法出口</code>、等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p> <p>局部变量表存放了编译器可知的各种基本数据类型<code>(boolean、byte、char、short、int、float、long、double)</code>，对象引用<code>(reference类型</code>，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和<code>returnAdress类型</code>(指向了一条字节码指令的地址)。</p> <p>其中64位长度的<code>long</code>和<code>double</code>类型的数据会占用2个局部变量空间<code>(Slot)</code>，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p> <p>在<code>Java虚拟机</code>规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机可以动态扩展（当前大部分<code>Java虚拟机</code>都可以动态扩展，只不过<code>Java</code>虚拟机规范中也允许固定长度的虚拟机栈），当扩展是无法申请到足够的内存时会抛出<code>OOM</code>异常。
<img src="https://img-blog.csdnimg.cn/20210707134716772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <h3 id="本地方法栈"><a href="#本地方法栈" class="header-anchor">#</a> 本地方法栈</h3> <p><code>Native Method Stacks</code>与虚拟机栈作用类似，其区别不过是虚拟机栈为虚拟机执行<code>Java</code>方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的<code>Native</code>方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（如<code>Sun HotSpot虚拟机</code>）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出<code>StackOverflowError</code>和<code>OOM</code>异常.</p> <p>方法的执行都是伴随着线程的。原始类型的本地变量以及引用都存放在线程栈中。而引用关联的对象比如<code>String</code>，都存在在堆中。为了更好的理解上面这段话，我们可以看一个例子：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>text<span class="token punctuation">.</span></span><span class="token class-name">SimpleDateFormat</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>log4j<span class="token punctuation">.</span></span><span class="token class-name">Logger</span></span><span class="token punctuation">;</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Logger</span> <span class="token constant">LOGGER</span> <span class="token operator">=</span> <span class="token class-name">Logger</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">HelloWorld</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SimpleDateFormat</span> formatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;dd.MM.YYYY&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> today <span class="token operator">=</span> formatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token constant">LOGGER</span><span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>today <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这段程序的数据在内存中的存放如下：
<img src="https://img-blog.csdnimg.cn/20210706160752161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <h3 id="outofmemoryerror"><a href="#outofmemoryerror" class="header-anchor">#</a> OutOfMemoryError</h3> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Exception</span> in thread “main”<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span> <span class="token class-name">Java</span> heap space
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>原因：对象不能被分配到堆内存中</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Exception</span> in thread “main”<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span> <span class="token class-name">PermGen</span> space
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>原因：类或者方法不能被加载到持久代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库；</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Exception</span> in thread “main”<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span> <span class="token class-name">Requested</span> array size exceeds <span class="token constant">VM</span> limit
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>原因：创建的数组大于堆内存的空间</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Exception</span> in thread “main”<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span> request  bytes <span class="token class-name"><span class="token namespace">for <span class="token punctuation">.</span></span> Out</span> of swap space<span class="token operator">?</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>原因：分配本地分配失败。<code>JNI</code>、本地库或者<code>Java虚拟机</code>都会从本地堆中分配内存空间。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Exception</span> in thread “main”<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>OutOfMemoryError</span><span class="token operator">:</span>  （<span class="token class-name">Native</span> method）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>原因：同样是本地方法内存分配失败，只不过是<code>JNI</code>或者本地方法或者<code>Java虚拟机</code>发现</p> <h2 id="为什么java要在虚拟机里运行"><a href="#为什么java要在虚拟机里运行" class="header-anchor">#</a> 为什么Java要在虚拟机里运行？</h2> <p><code>Java</code>作为一门高级语言，语法复杂，抽象程度高。因此，直接在硬件上运行这样复杂的程序并不现实。所以呢，在运行<code>Java</code>程序之前，需要对其进行一番转换。</p> <p>将<code>Java</code>程序转成<code>Java</code>字节码，这样便可以在不同平台上的虚拟机实现运行。这便是<code>一次编写，到处运行</code>。</p> <p>虚拟机的另外一个好处是它带来了一个托管环境，这个托管环境能代替我们处理一些代码中冗长而且容易出错的部分。比如自动内存管理与垃圾回收。除此之外，还提供了诸如数组越界、动态类型、安全权限等等动态检测，使得我们不用书写这些无关业务逻辑的代码。</p> <h2 id="java文件编译到执行的过程"><a href="#java文件编译到执行的过程" class="header-anchor">#</a> Java文件编译到执行的过程</h2> <p>1、<code>Java</code>源码<code>.java文件</code>首先通过<code>Java编译器</code>进行编译，其中编译原理包含6部分内容。</p> <p>2、字节码文件被<code>Java虚拟机</code>通过<code>类加载器</code>加载到内存，（加载后的<code>Java</code>类会被存放在<code>方法区</code>中，实际运行时，虚拟机会执行方法区中的代码。）并通过<code>字节码校验器</code>进行字节码的合法性校验，即可通过翻译字节码<code>(解释执行)</code>或者<code>JIT</code>编译器<code>(编译执行)</code>进行程序的运行，无论经过哪种方式，都需要经过不同操作系统提供的具体指令。</p> <p><img src="https://img-blog.csdnimg.cn/20210703172504696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20210703210351245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <blockquote><p>之所以称为Java字节码，是因为Java字节码指令的操作码（opcode）被固定为一个字节。</p></blockquote> <blockquote><p>解释执行：即逐条将字节码翻译成机器码进行执行。
即时编译：即将一个方法中包含的所有字节码编译成机器码后再执行。
前者优势在于无需等待编译，而后者的优势在于实际运行速度更快。HotSpot默认采用混合模式，综合了两者的优点。它会先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。</p></blockquote> <h2 id="jvm是如何执行方法调用"><a href="#jvm是如何执行方法调用" class="header-anchor">#</a> JVM是如何执行方法调用</h2> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VariableParameterDemo</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;1111111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;222222&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invokeInt</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;int&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invokeInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Integer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//222222</span>
        <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//222222</span>
        
        <span class="token comment">// 只有手动绕开可变长参数的语法糖，才能调用第一个 invoke 方法</span>
        <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">invokeInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 1、同一个类中出现多个名字相同，并且参数类型相同的方法，无法通过编译。
     * 也就是说，如果想在同一个类中定义名字相同的方法，那么它们参数类型必须不同。
     * 这些方法之间的关系，叫做重载。
     *
     * 重载除了同一个类中的方法，也可以作用于这个类所继承来的方法。
     * 也就是说，如果子类和父类中非私有方法同名的方法，而这两个方法参数类型不同，或参数长度不同，
     * 那么这两个方法同样构成了重载。
     *
     * 如果子类定义了与父类中非私有方法同名的方法，且两个方法的参数类型都相同。
     * 当这个两个方法都是静态的，那么子类中的方法隐藏了父类中的方法(super调用不到)
     * 当这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法。
     *
     * 2、重载的方法在编译过程中即可完成识别。具体到每一个方法调用，Java编译器会根据
     * 所传入参数的声明类型（注意于实际类型区分）来选取重载方法。
     *
     * 2.1、选取的过程分为三个阶段：
     * 1、在不考虑对基本类型自动装拆箱，以及可变长参数的情况下选取重载方法。
     * 2、如果在第一个阶段中没有找到适配的方法，那么在允许自动拆箱，但不允许可变长参数的情况下选取重载方法。
     * 3、如果在第二个阶段中没有找到适配的方法，那么在允许自动拆箱以及可变长参数的情况下选择重载方法。
     *
     * 如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，
     * 而决定贴切程度的一个关键就是形式参数类型的继承关系。
     *
     * 在上面invoke中，当传入 null 时，它既可以匹配第一个方法中声明为 Object 的形式参
     * 数，也可以匹配第二个方法中声明为 String 的形式参数。由于 String 是 Object 的子类，
     * 因此 Java 编译器会认为第二个方法更为贴切。
     */</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br></div></div><h3 id="jvm的静态绑定和动态绑定"><a href="#jvm的静态绑定和动态绑定" class="header-anchor">#</a> JVM的静态绑定和动态绑定</h3> <p>1、<code>Java虚拟机</code>识别方法的关键在于类名、方法名以及方法描述符。</p> <p>2、方法描述符：它是由方法的参数类型以及返回类型所构成的。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么<code>Java虚拟机</code>会在类验证阶段报错。</p> <p>3、<code>Java虚拟机</code>对方法的重写判断同样基于方法描述符。也就是说，如果子类定义了与父类中非私有，非静态方法同名的方法，那么只有当这两个方法的参数类型以及返回类型一致，才会被判定为重写。</p> <p>4、由于对重载方法的区分在编译阶段已经完成，可以认为<code>Java虚拟机</code>不存在重载这一概念。因此在某些地方，重载也被称为静态绑定，或者编译时多态，而重写则被称为动态绑定。</p> <p>这个说法在<code>Java虚拟机</code>语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此<code>Java编译器</code>会将所有对非私有实例方法的调用编译为需要动态绑定的类型。确切地说，<code>Java虚拟机</code>中的静态绑定是指在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。</p> <p><code>Java虚拟机</code>的动态绑定是通过方法表这一数据结构（本质就是个数组）来实现的。方法表中每一个重写方法的索引值，与父类方法表中被重写的方法的索引值一致。</p> <p>在解析虚方法（方法重写的方法，可认为就是虚方法）调用时，<code>Java虚拟机</code>会记录下所声明的目标方法的索引值，并且在运行时根据这个索引值查找具体的目标方法。</p> <p><code>Java虚拟机</code>中的即时编译器会使用内联缓存来加速动态绑定。<code>Java虚拟机</code>所采用的单态内联缓存将记录调用者的动态类型，以及它所对应的目标方法。当碰到新的调用者时，如果其动态类型与缓存中的类型匹配，则直接调用缓存的目标方法。否则，<code>Java虚拟机</code>将内联缓存劣化为超多态内联缓存，在今后的执行过程中直接使用方法表进行动态绑定。</p> <h2 id="jvm是如何处理异常的"><a href="#jvm是如何处理异常的" class="header-anchor">#</a> JVM是如何处理异常的？</h2> <h3 id="异常"><a href="#异常" class="header-anchor">#</a> 异常</h3> <p><code>Java</code>语言规范中，所有异常都是<code>Throwable</code>l类或者其子类的实例。</p> <p><code>Throwable</code>有两个直接子类</p> <p>1、<code>Error</code>：涵盖程序不应捕获的异常，当程序触发<code>Error</code>，它的执行状态已经无法恢复，需要中止线程甚至是中止虚拟机。</p> <p>2、<code>Exception</code>：涵盖程序可能需要捕获并且处理的异常。<code>Exception</code>有一个特殊的子类<code>RuntimeException</code>，用来表示“程序虽然无法继续执行，但是还能抢救一下”的情况。<code>RuntimeException</code>和<code>Error</code>都是非检查异常。其他的异常都属于检查异常。在<code>Java</code>中，所有的检查异常都需要程序显示的捕获。或者在方法声明中使用<code>throws</code>关键字标注。</p> <h3 id="jvm如何捕获异常"><a href="#jvm如何捕获异常" class="header-anchor">#</a> JVM如何捕获异常</h3> <p>在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常
处理器，并且由 <code>from</code> 指针、<code>to</code> 指针、<code>target</code>指针以及所捕获的异常类型构成。这些指针
的值是字节码索引<code>（bytecode index，bci）</code>，用以定位字节码。</p> <p>其中，<code>from</code> 指针和 <code>to</code> 指针标示了该异常处理器所监控的范围，例如 <code>try</code> 代码块所覆盖的
范围。<code>target</code> 指针则指向异常处理器的起始位置，例如 <code>catch</code> 代码块的起始位置。</p> <p>当程序触发异常时，<code>Java 虚拟机</code>会从上至下遍历异常表中的所有条目。当触发异常的字节
码的索引值在某个异常表条目的监控范围内，<code>Java 虚拟机</code>会判断所抛出的异常和该条目想
要捕获的异常是否匹配。如果匹配，<code>Java 虚拟机</code>会将控制流转移至该条目 <code>target</code>指针指向
的字节码。</p> <p>如果遍历完所有异常表条目，<code>Java 虚拟机</code>仍未匹配到异常处理器，那么它会弹出当前方法
对应的 <code>Java 栈帧</code>，并且在调用者<code>（caller）</code>中重复上述操作。在最坏情况下，<code>Java 虚拟机</code>
需要遍历当前线程<code>Java 栈</code>上所有方法的异常表。</p> <p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener noreferrer">从实际案例聊聊Java应用的GC优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="gc类型"><a href="#gc类型" class="header-anchor">#</a> GC类型</h2> <ul><li>Full GC （Major GC）：发生于老年代，耗时较长，发生频率低。</li> <li>Minor GC ： 发生于年轻代，耗时较短、发生频率高。</li></ul> <h2 id="gc原理"><a href="#gc原理" class="header-anchor">#</a> GC原理</h2> <p><img src="https://img-blog.csdnimg.cn/20210710104637279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <blockquote><p>GC大致过程</p></blockquote> <p>新生区是类的诞生、成长、消亡的区域，一个类在这产生，应用，最后被垃圾回收器收集，结束生命。</p> <p>新生区又分为两个部分：伊甸区<code>Eden</code>和幸存者区<code>Survivor</code>，所有的类都是在伊甸区被<code>new</code>出来的。幸存者区有两个：<code>from</code>区和<code>to</code>区。当伊甸园区的空间用完时，程序又需要创建对象，<code>JVM</code>的垃圾回收器将对伊甸园区进行垃圾回收<code>(Minor GC)</code>，将伊甸园区中的不在被其他对象所引用的对象进行销毁，然后将伊甸园区中的剩余对象移动到<code>from</code>区，若<code>from</code>区也满了，再对该区进行垃圾回收，然后移动到<code>to</code>区，</p> <p>如果<code>to</code>区也满了，再移动到养老区，若养老区也满了，这时将产生<code>Major GC(Full GC)</code>，进行养老区的内存清理，若养老区执行了清理之后依然无法进行对象的保存，就会报<code>OOM</code>异常。</p> <blockquote><p>Minor GC 过程</p></blockquote> <ol><li><p><code>Eden</code>、<code>Survivor From</code>复制到<code>Survivor To</code>，年龄+1
首次，当<code>Eden</code>区满的时候会触发第一次<code>GC</code>，把还活着的对象拷贝到<code>Survivor From</code>区，当<code>Eden</code>区再次触发<code>GC</code>的时候会扫描<code>Eden</code>区和<code>From</code>区域，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到<code>To</code>区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1。</p></li> <li><p>清空<code>Eden</code>、<code>Survivor From</code>
然后清空<code>Eden</code>、<code>Survivor From</code>中的对象</p></li> <li><p>复制之后又交换，谁空谁是<code>To</code>
最后，<code>Survivor From</code>和<code>Survivor To</code>互换，原<code>Survivor</code> 成为下一次<code>GC</code>时的<code>Survivor From</code>区。部分对象会在<code>From</code>区和<code>To</code>区域中复制来复制去，如此交换默认15次（由<code>JVM</code>参数<code>MaxTenuringThreshold</code>控制，默认等于15），如果最终还是存活，就存入到老年代。</p></li></ol> <p>⽆论是<code>Minor GC</code>还是<code>Full GC</code>，都会产⽣停顿现象，即<code>Stop-the-World</code>。<code>Minor GC</code>停顿时间较短，⽽<code>Full GC</code>因耗时较⻓将导致⻓时间停顿、系统⽆响应，极⼤地影响系统性能。因此，对<code>Full GC</code>⽇志的监控及分析在性能优化中极为重要。</p> <h2 id="gc控制参数"><a href="#gc控制参数" class="header-anchor">#</a> GC控制参数</h2> <ul><li><p>-Xms设置堆的最小空间大小。</p></li> <li><p>-Xmx设置堆的最大空间大小。</p></li> <li><p>-XX:NewSize设置新生代最小空间大小。</p></li> <li><p>-XX:MaxNewSize设置新生代最大空间大小。</p></li> <li><p>-XX:PermSize设置永久代最小空间大小。</p></li> <li><p>-XX:MaxPermSize设置永久代最大空间大小。</p></li> <li><p>-Xss设置每个线程的堆栈大小。</p></li> <li><p>-XX:NewRatio设置老年代的占比,剩下的1给新生代</p></li> <li><p>-XX:SurvivorRatio设置<code>Eden</code>区与每一个<code>Survivor</code>区的比值</p></li> <li><p>-XX:MaxTenuringThreshold 来设定年轻代对象移动到老年代年龄，默认年龄是 15 岁。</p></li></ul> <p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p> <p>老年代空间大小=堆空间大小-年轻代大空间大小</p> <h2 id="gc日志"><a href="#gc日志" class="header-anchor">#</a> GC日志</h2> <ul><li>开启GC</li></ul> <p>在<code>JVM</code>中设置参数<code>-verbose:gc</code>或<code>-XX:+PrintGC</code>，默认<code>GC</code>日志是关闭的。</p> <ul><li>其他参数</li></ul> <p><code>-XX:+PrintGCDetails</code> 创建更详细的<code>GC</code>⽇志，默认关闭；</p> <p><code>-XX:+PrintGCTimeStamps</code>或<code>-XX:+PrintGCDateStamps</code> 可⽤于分析GC之间的时间间隔，默认关闭，建议开启；</p> <p><code>-Xloggc:filename</code> 指定将<code>GC</code>⽇志输出到具体⽂件，默认为标准输出；</p> <p>-<code>XX:NumberOfGCLogfiles</code>及<code>-XX:UseGCLogfileRotation</code> 控制⽇志⽂件循环，默认是0，即不作任何限制。</p> <h2 id="gc数据"><a href="#gc数据" class="header-anchor">#</a> GC数据</h2> <p><img src="https://img-blog.csdnimg.cn/20210710164605622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> <img src="https://img-blog.csdnimg.cn/20210710164716799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
通过<code>jstat -gc 23995 1000</code>可以实时查看<code>GC</code>情况，23995是进程号，1000是刷新频率-即1秒。
<img src="https://img-blog.csdnimg.cn/20210710164826683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RfQV9JX0hfQV9P,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">
参数说明</p> <ul><li>S0C：年轻代中第⼀个survivor（幸存区）的容量 (字节)</li> <li>S1C：年轻代中第⼆个survivor（幸存区）的容量 (字节)</li> <li>S0U：年轻代中第⼀个survivor（幸存区）⽬前已使⽤空间 (字节)</li> <li>S1U：年轻代中第⼆个survivor（幸存区）⽬前已使⽤空间 (字节)</li> <li>EC：年轻代中Eden（伊甸园）的容量 (字节)</li> <li>EU：年轻代中Eden（伊甸园）⽬前已使⽤空间 (字节)</li> <li>OC：Old代的容量 (字节)</li> <li>OU：Old代⽬前已使⽤空间 (字节)</li> <li>PC：Perm(持久代)的容量 (字节)</li> <li>PU：Perm(持久代)⽬前已使⽤空间 (字节)</li> <li>YGC：从应⽤程序启动到采样时年轻代中gc次数</li> <li>YGCT：从应⽤程序启动到采样时年轻代中gc所⽤时间(s)</li> <li>FGC：从应⽤程序启动到采样时old代(全gc)gc次数</li> <li>FGCT：从应⽤程序启动到采样时old代(全gc)gc所⽤时间(s)</li> <li>GCT：从应⽤程序启动到采样时gc⽤的总时间(s)</li></ul> <blockquote><p>http://gceasy.io是⼀个在线分析GC⽇志⼯具，国内访问速度和分析速度都较快，分析结果较为详细。分免费版、商业版等。</p></blockquote> <h2 id="性能分析和可监控的各种可视工具"><a href="#性能分析和可监控的各种可视工具" class="header-anchor">#</a> 性能分析和可监控的各种可视工具</h2> <p><a href="https://segmentfault.com/a/1190000038225249" target="_blank" rel="noopener noreferrer">给，你们想要的排查问题的可视化工具<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://www.ityouknow.com/jvm/2017/09/22/jvm-tool.html" target="_blank" rel="noopener noreferrer">Jvm 系列(七):Jvm 调优-工具篇<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="判断对象存亡"><a href="#判断对象存亡" class="header-anchor">#</a> 判断对象存亡</h2> <blockquote><p>引用计数法</p></blockquote> <ul><li>为每一个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以回收了。</li> <li>具体实现：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数+1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器-1。也就是说，我们需要截获所有的引用更新操作，并相应地增减目标对象的引用计数器。</li> <li>缺点：无法处理循环引用对象。比如对象a与b相互引用，除此之外没有其他引用指向a或者b。在这种情况下，a和b实际上已经死了，但由于他们的引用计数器皆不为0，在引用计数法中，这两个对象还活着。因此，这些循环对象所占据的空间将不可回收，从而造成了内存泄漏。</li></ul> <blockquote><p>可达性分析算法</p></blockquote> <ul><li>将一系列<code>GC Roots</code>作为初始的存活对象集合，然后从该集合出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程也称之为标记。最终，没有被探索到的对象便是死亡的，是可以回收的。</li> <li><code>GC Roots</code>:可理解为由堆外指向堆内的引用，一般而言，<code>GC Roots</code>包括（但不限于）以下几种</li></ul> <p>1、<code>Java</code>方法栈帧中的局部变量
2、已加载类的静态变量
3、JNI handles
4、已启动且未停止的<code>Java</code>线程</p> <ul><li>可达性分析可以解决引用计数法所不能解决的循环问题。即时对象a和b相互引用，只要<code>GC Roots</code>出发无法到达a和b，那么可达性分析便不会将它们加入存活对象合集中。</li> <li>缺点：在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为null）或者漏报（将引用设置为未被访问过的对象）。</li></ul> <h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="header-anchor">#</a> 垃圾回收算法</h2> <p><a href="https://www.cnblogs.com/chenpt/p/9799095.html" target="_blank" rel="noopener noreferrer">Jvm垃圾回收器（算法篇）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="垃圾回收器"><a href="#垃圾回收器" class="header-anchor">#</a> 垃圾回收器</h2> <p><a href="https://www.cnblogs.com/chenpt/p/9803298.html" target="_blank" rel="noopener noreferrer">Jvm垃圾回收器（终结篇）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="jvm调优"><a href="#jvm调优" class="header-anchor">#</a> JVM调优</h2> <p><a href="https://www.liaoxuefeng.com/article/1336345083510818" target="_blank" rel="noopener noreferrer">JVM调优的正确姿势<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">2/24/2025, 4:18:47 PM</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/MyBlog/assets/js/app.9dfd65aa.js" defer></script><script src="/MyBlog/assets/js/3.76fec40c.js" defer></script><script src="/MyBlog/assets/js/1.0933c2a3.js" defer></script><script src="/MyBlog/assets/js/57.9b6b522b.js" defer></script>
  </body>
</html>
